<!DOCTYPE html> <html class="ooixoaqn idc0_343" style lang=en><!--
 Page saved with SingleFile 
 url: https://zserge.com/posts/post-apocalyptic-programming/ 
 saved date: Thu Dec 22 2022 17:52:45 GMT+0000 (Greenwich Mean Time)
--><meta charset=utf-8><title>Post-apocalyptic programming</title><meta name=description content="In a post-apocalyptic future with no internet or stackoverflow, let's try to build a programming environment from scratch."><meta name=author content="Serge Zaitsev"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" sizes=192x192 href="data:image/png;base64,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" data-sf-original-href=https://zserge.com/favicon-192x192.png><link rel=alternate type=application/rss+xml title=RSS href=https://zserge.com/rss.xml><link rel=canonical href=https://zserge.com/posts/post-apocalyptic-programming/><meta property=og:title content="Post-apocalyptic programming"><meta property=og:type content=article><meta property=og:url content=https://zserge.com/posts/post-apocalyptic-programming/><meta property=og:image content=https://zserge.com/logo.png><meta property=og:description content="In a post-apocalyptic future with no internet or stackoverflow, let's try to build a programming environment from scratch."><meta property=og:locale content=en_US><meta name=twitter:card content="In a post-apocalyptic future with no internet or stackoverflow, let's try to build a programming environment from scratch."><meta name=twitter:site content=@zsergo><style>body{padding:1rem;margin:auto;max-width:46rem;font-family:pt serif,Georgia,Cambria,times new roman,Times,serif;line-height:1.5;font-size:20px;color:rgba(0,0,0,.87);-webkit-font-smoothing:antialiased;font-weight:300}nav{display:flex;justify-content:space-between;align-items:center;margin:1em 0 3em}nav ul,nav li{display:inline-block;list-style:none;margin:0 0 0 .5rem;padding:0}nav ul{margin-right:1rem}.logo{background-color:rgba(0,0,0,.87);color:#fff;min-width:48px;min-height:48px;font-size:28px;border-radius:2px;display:flex;justify-content:center;align-items:center}.logo:hover{color:#fff}h1,h2{line-height:1.2;font-family:roboto,system-ui,segoe ui,Helvetica,Arial,sans-serif;font-weight:400;text-transform:uppercase;margin:1.34em 0 0}h1{font-size:1.95em}h2{font-size:1.25em;border-bottom:2px solid rgba(0,0,0,.87)}p{margin:.67em 0 1em}a{color:#0076df;text-decoration:none;word-break:break-word}a:hover{color:rgba(0,0,0,.87)}ul{list-style-position:outside;margin-left:1em}img{display:block;margin-left:auto;margin-right:auto;max-width:100%}pre,code{font-family:roboto mono,SFMono-Regular,Consolas,liberation mono,Menlo,monospace;font-weight:400;font-size:18px;color:rgba(0,0,0,.6);background:#eee}code{padding:.2rem .4rem;font-size:14px;border-radius:2px}pre{overflow-y:auto;line-height:20px;border-radius:2px;padding:1em}pre code{font-size:14px;padding:0;color:rgba(0,0,0,.87)}footer{font-size:12px}@media (prefers-color-scheme:dark){.logo{color:#444;background-color:#e4e4e4}.logo:hover{color:#444}body{background-color:#444;color:#e4e4e4}pre,pre code{background:#333;color:#e4e4e4}h2{border-bottom:1px solid #e4e4e4}code{color:#aaa;background:#333}a{color:#e39777}a:hover{color:#e4e4e4}img{filter:grayscale(30%)}}.nc,.kn,.k{font-weight:700}.cm,.c1{color:#777}.sf-hidden{display:none!important}</style><meta http-equiv=content-security-policy content="default-src 'none'; font-src 'self' data:; img-src 'self' data:; style-src 'unsafe-inline'; media-src 'self' data:; script-src 'unsafe-inline' data:; object-src 'self' data:;"><style>img[src="data:,"],source[src="data:,"]{display:none!important}</style><body><header><nav><a class=logo href=https://zserge.com/>Z</a><ul><li><a href=https://zserge.com/about/>about</a><li><a href=https://zserge.com/posts/>posts</a><li><a href=https://twitter.com/zsergo rel=me>@me</a><li><a href=https://github.com/zserge rel=me>&lt;/&gt;me</a></ul></nav></header><div id=content><h1>Post-apocalyptic programming</h1><p>We got deadly viruses, nuclear war threats, economy heading from one crisis to another deeper crisis, politicians going out of control… You know that feeling. The end is near, isn’t it?<p>But let’s talk about brighter things – technology. We are all smart people, working on valuable and complex software projects in great agile teams, copying code from Stack Overflow and using GitHub co-pilot to help us with the routine.<p>Now, what if you are the only survivor with some programming skills sitting in front of a computer you’ve never heard of, with some hex pad to enter machine codes, with maybe some pen and paper. What will you do?<p>In this not-so-short article we will try to go a full cycle from exploring the CPU, building an assembler, building the core of the Forth VM and finally building a reasonably useful Forth interpreter. Beware, this might contain unwanted low-level details as well as some meta-programming parts.<p>If code speaks better to you then words - you may find the emulator, the assembler, the VM and the Forth code sample at <a href=https://github.com/zserge/lc3-forth>github.com/zserge/lc3-forth</a>. It’s only 0.5KB of machine code, or ~400 lines of C.<h2 id=the-cpu>The CPU</h2><p>If we managed to get a chip crisis in a peaceful modern era – then in a post-apocalyptic world I wouldn’t rely on a good supply for x86 or ARM64 chips. Not to mention those would be very hard to program by hand. Instead I would imagine some low-end microcontrollers with a dozen of supported primitive instructions. Something even a hobbyist could <a href=https://coertvonk.com/inquiries/how-cpu-work/implementation-30975>build in Verilog</a>.<p>To keep things fun let’s start with something simple and familiar, probably the CPU you’ve learned during your CS classes. I’m talking about the good old LC-3. It’s known to be a good educational model, and the instruction set is super tiny and convenient to be entered by hand in hexadecimal form:<p><img src="data:image/gif;base64,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" alt="LC-3 instruction set" data-sf-original-src=https://zserge.com/images/lc3.gif><p>There are 15 instructions that we care about: <code>ADD</code>, <code>AND</code>, <code>NOT</code> are the only arithmetic operations we got, <code>BR</code>, <code>JMP</code>, <code>JSR</code> and <code>RET</code> are the only branching instructions, <code>LD</code>, <code>LDI</code>, <code>LDR</code> with <code>ST</code> <code>STI</code>, <code>STR</code> counterparts are all load/store instructions, <code>LEA</code> helps with indirect addressing and <code>TRAP</code> handles the I/O.<p>It’s a 16-bit CPU that is even incapable of loading an 8-bit immediate value into its registers. It got 8 registers in total, of which the last one is used as a return address pointer for subroutines, so should be used with care. The rest are pretty orthogonal.<p>To simulate our apocalypse let’s start with an emulator for this toy CPU, it shouldn’t be too hard.<h2 id=lc-3-simulator>LC-3 Simulator</h2><p>I will be using C to keep the grim atmosphere of the apocalypse, but you may try this exercise in a different language, of course.<p>We know that LC-3 stores code and data together, has 8 registers and the instruction cycle works as follows: it fetches the next instruction from memory increasing the program counter, it decodes the fetched instruction, it evaluates the relative addresses if needed, loads operands such as registers or immediate values, executes the operation and stores the result in a register or in memory.<p>Our emulator would be a function that performs one instruction cycle. Calling that function in a loop would execute the LC-3 program.<p>Two things to consider prior to that is how LC-3 handles negative numbers and how it handles the braching flags. LC-3 has a concept of <a href=https://en.wikipedia.org/wiki/Sign_extension>“sign extension”</a> - an operation of increasing the number of bits in an integer while preserving the sign and the value. You may have noticed that some instructions use lower bits for immediate values - it may be 6 lowest bits, or 9 lowest bits. At the end these become 16-bit numbers, because the CPU deals only with 16-bit values. The CPU extends such operands into 16-bit numbers keeping their sign. In C we can implement it like this:<div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=k>static</span> <span class=kt>int</span> <span class=nf>sext</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>bits</span><span class=p>)</span> <span class=p>{</span>
  <span class=kt>int</span> <span class=n>m</span> <span class=o>=</span> <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=n>bits</span> <span class=o>-</span> <span class=mi>1</span><span class=p>));</span>
  <span class=kt>int</span> <span class=n>n</span> <span class=o>=</span> <span class=n>x</span> <span class=o>&amp;</span> <span class=p>((</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>bits</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>);</span>
  <span class=k>return</span> <span class=p>(</span><span class=n>n</span> <span class=o>^</span> <span class=n>m</span><span class=p>)</span> <span class=o>-</span> <span class=n>m</span><span class=p>;</span>
<span class=p>}</span>

<span class=n>sext</span><span class=p>(</span><span class=mh>0x15</span><span class=p>,</span> <span class=mi>5</span><span class=p>);</span> <span class=c1>// =&gt; 10101 becomes 11111111 11110101 = 0xfff5 = -11
</span><span class=c1></span><span class=n>sext</span><span class=p>(</span><span class=mh>0x05</span><span class=p>,</span> <span class=mi>5</span><span class=p>);</span> <span class=c1>// =&gt; 00101 becomes 00000000 00000101 = 0x0005 =   5
</span></code></pre></div><p>When it comes to branching, LC-3 supports 3 conditional flags stored in a special non-addressable register, these flags are updated after all arithmetic and load instructions. They are <code>Z</code> (result is zero), <code>P</code> (result is positive) or <code>N</code> (result is negative). Only one flag can be set at a time. We could have a convenience function for them:<div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=k>static</span> <span class=kt>int</span> <span class=nf>flags</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
  <span class=k>return</span> <span class=p>(</span><span class=n>x</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=o>*</span> <span class=mi>4</span> <span class=o>+</span> <span class=p>(</span><span class=n>x</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=o>*</span> <span class=mi>2</span> <span class=o>+</span> <span class=p>(</span><span class=n>x</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div><p>We are ready to write our LC-3 instruction handler:<div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=cp>#define OP(_hint, code, body) case code: body; return pc;
</span><span class=cp>#define CC(x) reg[8] = flags(x)
</span><span class=cp></span><span class=k>static</span> <span class=kt>int</span> <span class=nf>lc3</span><span class=p>(</span><span class=kt>int</span> <span class=o>*</span><span class=n>mem</span><span class=p>,</span> <span class=kt>int</span> <span class=o>*</span><span class=n>reg</span><span class=p>,</span> <span class=kt>int</span> <span class=n>pc</span><span class=p>)</span> <span class=p>{</span>
  <span class=kt>int</span> <span class=n>op</span> <span class=o>=</span> <span class=n>mem</span><span class=p>[</span><span class=n>pc</span><span class=p>];</span>
  <span class=kt>int</span> <span class=n>x</span> <span class=o>=</span> <span class=p>(</span><span class=n>op</span> <span class=o>&gt;&gt;</span> <span class=mi>9</span><span class=p>)</span> <span class=o>&amp;</span> <span class=mi>7</span><span class=p>;</span>
  <span class=kt>int</span> <span class=n>y</span> <span class=o>=</span> <span class=p>(</span><span class=n>op</span> <span class=o>&gt;&gt;</span> <span class=mi>6</span><span class=p>)</span> <span class=o>&amp;</span> <span class=mi>7</span><span class=p>;</span>
  <span class=kt>int</span> <span class=n>z</span> <span class=o>=</span> <span class=p>(</span><span class=n>op</span> <span class=o>&amp;</span> <span class=mh>0x3f</span><span class=p>);</span>
  <span class=n>pc</span><span class=o>++</span><span class=p>;</span>
  <span class=k>switch</span> <span class=p>(</span><span class=n>op</span> <span class=o>&gt;&gt;</span> <span class=mi>12</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>OP</span><span class=p>(</span><span class=n>BR</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span> <span class=n>pc</span> <span class=o>+=</span> <span class=p>(</span><span class=n>reg</span><span class=p>[</span><span class=mi>8</span><span class=p>]</span> <span class=o>&amp;</span> <span class=n>x</span><span class=p>)</span> <span class=o>?</span> <span class=n>sext</span><span class=p>(</span><span class=n>op</span><span class=p>,</span> <span class=mi>9</span><span class=p>)</span> <span class=o>:</span> <span class=mi>0</span><span class=p>)</span>
    <span class=n>OP</span><span class=p>(</span><span class=n>ADD</span><span class=p>,</span>  <span class=mi>1</span><span class=p>,</span> <span class=n>CC</span><span class=p>(</span><span class=n>reg</span><span class=p>[</span><span class=n>x</span><span class=p>]</span> <span class=o>=</span> <span class=n>reg</span><span class=p>[</span><span class=n>y</span><span class=p>]</span> <span class=o>+</span> <span class=p>((</span><span class=n>z</span> <span class=o>&amp;</span> <span class=mh>0x20</span><span class=p>)</span> <span class=o>?</span> <span class=n>sext</span><span class=p>(</span><span class=n>op</span><span class=p>,</span> <span class=mi>5</span><span class=p>)</span> <span class=o>:</span> <span class=n>reg</span><span class=p>[</span><span class=n>z</span><span class=p>])))</span>
    <span class=n>OP</span><span class=p>(</span><span class=n>LD</span><span class=p>,</span>   <span class=mi>2</span><span class=p>,</span> <span class=n>CC</span><span class=p>(</span><span class=n>reg</span><span class=p>[</span><span class=n>x</span><span class=p>]</span> <span class=o>=</span> <span class=n>mem</span><span class=p>[</span><span class=n>pc</span> <span class=o>+</span> <span class=n>sext</span><span class=p>(</span><span class=n>op</span><span class=p>,</span> <span class=mi>9</span><span class=p>)]))</span>
    <span class=n>OP</span><span class=p>(</span><span class=n>ST</span><span class=p>,</span>   <span class=mi>3</span><span class=p>,</span> <span class=n>mem</span><span class=p>[</span><span class=n>pc</span> <span class=o>+</span> <span class=n>sext</span><span class=p>(</span><span class=n>op</span><span class=p>,</span> <span class=mi>9</span><span class=p>)]</span> <span class=o>=</span> <span class=n>reg</span><span class=p>[</span><span class=n>x</span><span class=p>]);</span>
    <span class=n>OP</span><span class=p>(</span><span class=n>JSR</span><span class=p>,</span>  <span class=mi>4</span><span class=p>,</span> <span class=p>(</span><span class=n>reg</span><span class=p>[</span><span class=mi>7</span><span class=p>]</span> <span class=o>=</span> <span class=n>pc</span><span class=p>,</span> <span class=n>pc</span> <span class=o>=</span> <span class=n>pc</span> <span class=o>+</span> <span class=n>sext</span><span class=p>(</span><span class=n>op</span><span class=p>,</span> <span class=mi>9</span><span class=p>)))</span>
    <span class=n>OP</span><span class=p>(</span><span class=n>AND</span><span class=p>,</span>  <span class=mi>5</span><span class=p>,</span> <span class=n>CC</span><span class=p>(</span><span class=n>reg</span><span class=p>[</span><span class=n>x</span><span class=p>]</span> <span class=o>=</span> <span class=n>reg</span><span class=p>[</span><span class=n>y</span><span class=p>]</span> <span class=o>&amp;</span> <span class=p>((</span><span class=n>z</span> <span class=o>&amp;</span> <span class=mh>0x20</span><span class=p>)</span> <span class=o>?</span> <span class=n>sext</span><span class=p>(</span><span class=n>op</span><span class=p>,</span> <span class=mi>5</span><span class=p>)</span> <span class=o>:</span> <span class=n>reg</span><span class=p>[</span><span class=n>z</span><span class=p>])));</span>
    <span class=n>OP</span><span class=p>(</span><span class=n>LDR</span><span class=p>,</span>  <span class=mi>6</span><span class=p>,</span> <span class=n>CC</span><span class=p>(</span><span class=n>reg</span><span class=p>[</span><span class=n>x</span><span class=p>]</span> <span class=o>=</span> <span class=n>mem</span><span class=p>[</span><span class=n>reg</span><span class=p>[</span><span class=n>y</span><span class=p>]</span> <span class=o>+</span> <span class=n>sext</span><span class=p>(</span><span class=n>op</span><span class=p>,</span> <span class=mi>6</span><span class=p>)]));</span>
    <span class=n>OP</span><span class=p>(</span><span class=n>STR</span><span class=p>,</span>  <span class=mi>7</span><span class=p>,</span> <span class=n>mem</span><span class=p>[</span><span class=n>reg</span><span class=p>[</span><span class=n>y</span><span class=p>]</span> <span class=o>+</span> <span class=n>sext</span><span class=p>(</span><span class=n>op</span><span class=p>,</span> <span class=mi>6</span><span class=p>)]</span> <span class=o>=</span> <span class=n>reg</span><span class=p>[</span><span class=n>x</span><span class=p>]);</span>
    <span class=n>OP</span><span class=p>(</span><span class=n>NOT</span><span class=p>,</span>  <span class=mi>9</span><span class=p>,</span> <span class=n>CC</span><span class=p>(</span><span class=n>reg</span><span class=p>[</span><span class=n>x</span><span class=p>]</span> <span class=o>=</span> <span class=o>~</span><span class=n>reg</span><span class=p>[</span><span class=n>y</span><span class=p>]));</span>
    <span class=n>OP</span><span class=p>(</span><span class=n>LDI</span><span class=p>,</span> <span class=mi>10</span><span class=p>,</span> <span class=n>CC</span><span class=p>(</span><span class=n>reg</span><span class=p>[</span><span class=n>x</span><span class=p>]</span> <span class=o>=</span> <span class=n>mem</span><span class=p>[</span><span class=n>mem</span><span class=p>[</span><span class=n>pc</span> <span class=o>+</span> <span class=n>sext</span><span class=p>(</span><span class=n>op</span><span class=p>,</span> <span class=mi>9</span><span class=p>)]]));</span>
    <span class=n>OP</span><span class=p>(</span><span class=n>STI</span><span class=p>,</span> <span class=mi>11</span><span class=p>,</span> <span class=n>mem</span><span class=p>[</span><span class=n>mem</span><span class=p>[</span><span class=n>pc</span> <span class=o>+</span> <span class=n>sext</span><span class=p>(</span><span class=n>op</span><span class=p>,</span> <span class=mi>9</span><span class=p>)]]</span> <span class=o>=</span> <span class=n>reg</span><span class=p>[</span><span class=n>x</span><span class=p>]);</span>
    <span class=n>OP</span><span class=p>(</span><span class=n>JMP</span><span class=p>,</span> <span class=mi>12</span><span class=p>,</span> <span class=n>pc</span> <span class=o>=</span> <span class=n>reg</span><span class=p>[</span><span class=n>y</span><span class=p>]);</span>
    <span class=n>OP</span><span class=p>(</span><span class=n>LEA</span><span class=p>,</span> <span class=mi>14</span><span class=p>,</span> <span class=n>CC</span><span class=p>(</span><span class=n>reg</span><span class=p>[</span><span class=n>x</span><span class=p>]</span> <span class=o>=</span> <span class=n>pc</span> <span class=o>+</span> <span class=n>sext</span><span class=p>(</span><span class=n>op</span><span class=p>,</span> <span class=mi>9</span><span class=p>)));</span>
    <span class=n>OP</span><span class=p>(</span><span class=n>TRAP</span><span class=p>,</span><span class=mi>15</span><span class=p>,</span> <span class=p>(</span><span class=n>z</span> <span class=o>==</span> <span class=mh>0x20</span><span class=p>)</span> <span class=o>?</span> <span class=n>reg</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=n>getchar</span><span class=p>()</span> <span class=o>:</span> <span class=p>(</span><span class=n>z</span> <span class=o>==</span> <span class=mh>0x21</span><span class=p>)</span> <span class=o>?</span> <span class=n>putchar</span><span class=p>(</span><span class=n>reg</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span> <span class=o>:</span> <span class=p>(</span><span class=n>pc</span> <span class=o>=</span> <span class=p>(</span><span class=n>z</span> <span class=o>==</span> <span class=mh>0x25</span> <span class=o>?</span> <span class=o>-</span><span class=mi>1</span> <span class=o>:</span> <span class=n>pc</span><span class=p>)));</span>
  <span class=p>}</span>
  <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p>We start with fetching the instruction (<code>op = mem[pc]</code>), then decoding it into x/y/z parts, where X is usually a destination register, Y is the source register and Z is the immediate part. Not all instructions use them like that, but most do. We increase the PC as part of the fetch phase, and check the top 4 bits of the opcode.<p>The <code>OP</code> macro defines an operation, mnemonics for better clarity, and the body of the operation as a single C statement, typically <code>reg[x] = ...</code> or <code>mem[..] = ...</code>. At the end OP returns the PC, which might be modified by the operation.<p><code>CC</code> macro set the flag register depending on the value of the result, and returns the result. Branching, store and trap instructions don’t change CC flags, but other operations do.<p><code>AND</code> and <code>ADD</code> instructions check for the <code>0x20</code> (bit 6) to decide if the operant is an immediate value or a register. <code>TRAP</code> is the longest operation. It handles 0x20 trap to read a byte from console, 0x21 trap to print a byte and 0x25 to terminate the execution. When <code>pc</code> becomes negative - the emulator should stop.<p>Running LC-3 programs with this emulator is as simple as:<div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=kt>int</span> <span class=n>asmbuf</span><span class=p>[</span><span class=mh>0xffff</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span> <span class=p>...</span> <span class=n>LC</span><span class=o>-</span><span class=mi>3</span> <span class=n>program</span> <span class=p>...</span> <span class=p>};</span>
<span class=kt>int</span> <span class=n>pc</span> <span class=o>=</span> <span class=mh>0x3000</span><span class=p>;</span>
<span class=kt>int</span> <span class=n>reg</span><span class=p>[</span><span class=mi>9</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=mi>0</span><span class=p>};</span>
<span class=k>while</span> <span class=p>(</span><span class=n>pc</span><span class=p>)</span> <span class=p>{</span>
  <span class=n>pc</span> <span class=o>=</span> <span class=n>lc3</span><span class=p>(</span><span class=n>asmbuf</span><span class=p>,</span> <span class=n>reg</span><span class=p>,</span> <span class=n>pc</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div><p>Even though it’s possible to write LC-3 programs by hand using hexadecimal machine codes, we have a tough road ahead, so let’s build a small assembler.<h2 id=lc-3-assembler>LC-3 Assembler</h2><p>Since we started with C, I would reuse the language for assembly as well. Instead of writing a CLI tool that parses assembler syntax and generates machine code, I’d rather create some helper C functions that would fill <code>asmbuf</code> with machine codes. In this case we would be able to assemble and run machine code from the same C program.<p>Let’s introduce <code>asmptr</code> pointer to <code>asmbuf</code>, that would be advanced with every assembly instruction compiled:<div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=k>static</span> <span class=kt>int</span> <span class=n>asmbuf</span><span class=p>[</span><span class=mh>0xffff</span><span class=p>];</span>
<span class=k>static</span> <span class=kt>int</span> <span class=o>*</span><span class=n>asmptr</span> <span class=o>=</span> <span class=n>asmbuf</span> <span class=o>+</span> <span class=mh>0x3000</span><span class=p>;</span>
<span class=p>...</span>
<span class=k>static</span> <span class=kt>void</span> <span class=n>RET</span><span class=p>()</span>                      <span class=p>{</span> <span class=o>*</span><span class=n>asmptr</span><span class=o>++</span> <span class=o>=</span> <span class=mh>0xc1c0</span><span class=p>;</span> <span class=p>}</span>
<span class=k>static</span> <span class=kt>void</span> <span class=n>TRAP</span><span class=p>(</span><span class=kt>int</span> <span class=n>op</span><span class=p>)</span>               <span class=p>{</span> <span class=o>*</span><span class=n>asmptr</span><span class=o>++</span> <span class=o>=</span> <span class=mh>0xf000</span> <span class=o>|</span> <span class=p>(</span><span class=n>op</span> <span class=o>&amp;</span> <span class=mh>0xff</span><span class=p>);</span> <span class=p>}</span>
<span class=p>...</span>
</code></pre></div><p>What about instructions that take register operands? We would need an enum of all available registers R0..R7. But how do we tell a register from an immediate value? We could introduce special functions <code>ADDI</code> and <code>ANDI</code> to deal with immediate values, but we might not need that. We only need to represent registers 0..7 and immediate numbers in the range -15..15. So we can use a special mask, say top 4 bits to be set to <code>1010</code> for register and <code>1111</code>/<code>0000</code> for negative or positive immediates:<div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=cp>#define _R(n) ((n &amp; 7) | 0xa000) </span><span class=cm>/* helper to define register enum */</span><span class=cp>
</span><span class=cp>#define NR(r) (r &amp; 7)            </span><span class=cm>/* register number 0..7 */</span><span class=cp>
</span><span class=cp>#define DR(r) (NR(r) &lt;&lt; 9)       </span><span class=cm>/* destination register operand */</span><span class=cp>
</span><span class=cp>#define SR(r) (NR(r) &lt;&lt; 6)       </span><span class=cm>/* source register operand */</span><span class=cp>
</span><span class=cp>#define IR(x) (((x &gt;&gt; 12) == 0xa) ? NR(x) : ((x &amp; 0x1f) | 0x20)) </span><span class=cm>/* imm or reg */</span><span class=cp>
</span><span class=cp>#define A9(a) ((a) &amp; 0x1ff)      </span><span class=cm>/* PCOffset9 nine-bit arg */</span><span class=cp>
</span><span class=cp></span>
<span class=k>enum</span> <span class=p>{</span><span class=n>R0</span> <span class=o>=</span> <span class=n>_R</span><span class=p>(</span><span class=mi>0</span><span class=p>),</span> <span class=n>R1</span> <span class=o>=</span> <span class=n>_R</span><span class=p>(</span><span class=mi>1</span><span class=p>),</span> <span class=n>R2</span> <span class=o>=</span> <span class=n>_R</span><span class=p>(</span><span class=mi>2</span><span class=p>),</span> <span class=n>R3</span> <span class=o>=</span> <span class=n>_R</span><span class=p>(</span><span class=mi>3</span><span class=p>),</span> <span class=n>R4</span> <span class=o>=</span> <span class=n>_R</span><span class=p>(</span><span class=mi>4</span><span class=p>),</span> <span class=n>R5</span> <span class=o>=</span> <span class=n>_R</span><span class=p>(</span><span class=mi>5</span><span class=p>),</span> <span class=n>R6</span> <span class=o>=</span> <span class=n>_R</span><span class=p>(</span><span class=mi>6</span><span class=p>),</span> <span class=n>R7</span> <span class=o>=</span> <span class=n>_R</span><span class=p>(</span><span class=mi>7</span><span class=p>)};</span>
</code></pre></div><p>What’s left is jumps and addresses. In a normal assembler there are labels where code can jump to. We would have to use C variables for labels. It would be more convenient for assembler “instructions” to return current address where the instruction is stored. The we could write assembly like this:<div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>int label;
label = ADD(R0, R0, 1);
        BR(label);
</code></pre></div><p>Since we have <code>asmptr</code> pointer - the offset between that and <code>asmbuf</code> is the address. We can define a helper that returns that difference and use that in all instructions. After all these tweaks we finally have all instructions ready:<div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=k>static</span> <span class=kt>int</span> <span class=n>asmbuf</span><span class=p>[</span><span class=mh>0xffff</span><span class=p>],</span> <span class=o>*</span><span class=n>asmptr</span> <span class=o>=</span> <span class=n>asmbuf</span> <span class=o>+</span> <span class=mh>0x3000</span><span class=p>,</span> <span class=n>asmrun</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
<span class=cp>#define _R(n) ((n &amp; 7) | 0xa000) </span><span class=cm>/* helper to define register enum */</span><span class=cp>
</span><span class=cp>#define NR(r) (r &amp; 7)            </span><span class=cm>/* register number 0..7 */</span><span class=cp>
</span><span class=cp>#define DR(r) (NR(r) &lt;&lt; 9)       </span><span class=cm>/* destination register arg */</span><span class=cp>
</span><span class=cp>#define SR(r) (NR(r) &lt;&lt; 6)       </span><span class=cm>/* source register arg */</span><span class=cp>
</span><span class=cp>#define IR(x) (((x &gt;&gt; 12) == 0xa) ? NR(x) : ((x &amp; 0x1f) | 0x20)) </span><span class=cm>/* imm or reg */</span><span class=cp>
</span><span class=cp>#define A9(a) ((a) &amp; 0x1ff)        </span><span class=cm>/* PCOffset9 arg */</span><span class=cp>
</span><span class=cp></span>
<span class=k>enum</span> <span class=p>{</span><span class=n>R0</span> <span class=o>=</span> <span class=n>_R</span><span class=p>(</span><span class=mi>0</span><span class=p>),</span> <span class=n>R1</span> <span class=o>=</span> <span class=n>_R</span><span class=p>(</span><span class=mi>1</span><span class=p>),</span> <span class=n>R2</span> <span class=o>=</span> <span class=n>_R</span><span class=p>(</span><span class=mi>2</span><span class=p>),</span> <span class=n>R3</span> <span class=o>=</span> <span class=n>_R</span><span class=p>(</span><span class=mi>3</span><span class=p>),</span> <span class=n>R4</span> <span class=o>=</span> <span class=n>_R</span><span class=p>(</span><span class=mi>4</span><span class=p>),</span> <span class=n>R5</span> <span class=o>=</span> <span class=n>_R</span><span class=p>(</span><span class=mi>5</span><span class=p>),</span> <span class=n>R6</span> <span class=o>=</span> <span class=n>_R</span><span class=p>(</span><span class=mi>6</span><span class=p>),</span> <span class=n>R7</span> <span class=o>=</span> <span class=n>_R</span><span class=p>(</span><span class=mi>7</span><span class=p>)};</span>

<span class=cp>#define _L(x)            { x; return asmptr - asmbuf - 1; }
</span><span class=cp></span><span class=k>static</span> <span class=kt>int</span> <span class=nf>PC</span><span class=p>()</span>          <span class=p>{</span> <span class=k>return</span> <span class=n>asmptr</span> <span class=o>-</span> <span class=n>asmbuf</span><span class=p>;</span> <span class=p>}</span>
<span class=k>static</span> <span class=kt>int</span> <span class=nf>DW</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>)</span>     <span class=p>{</span> <span class=o>*</span><span class=n>asmptr</span><span class=o>++</span> <span class=o>=</span> <span class=n>n</span><span class=p>;</span> <span class=k>return</span> <span class=n>PC</span><span class=p>()</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span> <span class=p>}</span>
<span class=k>static</span> <span class=kt>int</span> <span class=nf>LL</span><span class=p>(</span><span class=kt>int</span> <span class=n>label</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=n>label</span> <span class=o>-</span> <span class=n>PC</span><span class=p>()</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span> <span class=p>}</span>

<span class=k>static</span> <span class=kt>int</span> <span class=nf>BR</span><span class=p>(</span><span class=kt>int</span> <span class=n>addr</span><span class=p>)</span>               <span class=p>{</span> <span class=n>_L</span><span class=p>(</span><span class=o>*</span><span class=n>asmptr</span><span class=o>++</span> <span class=o>=</span> <span class=mh>0x0e00</span> <span class=o>|</span> <span class=n>A9</span><span class=p>(</span><span class=n>LL</span><span class=p>(</span><span class=n>addr</span><span class=p>)));</span> <span class=p>}</span>
<span class=k>static</span> <span class=kt>int</span> <span class=nf>BRN</span><span class=p>(</span><span class=kt>int</span> <span class=n>addr</span><span class=p>)</span>              <span class=p>{</span> <span class=n>_L</span><span class=p>(</span><span class=o>*</span><span class=n>asmptr</span><span class=o>++</span> <span class=o>=</span> <span class=mh>0x0800</span> <span class=o>|</span> <span class=n>A9</span><span class=p>(</span><span class=n>LL</span><span class=p>(</span><span class=n>addr</span><span class=p>)));</span> <span class=p>}</span>
<span class=k>static</span> <span class=kt>int</span> <span class=nf>BRZ</span><span class=p>(</span><span class=kt>int</span> <span class=n>addr</span><span class=p>)</span>              <span class=p>{</span> <span class=n>_L</span><span class=p>(</span><span class=o>*</span><span class=n>asmptr</span><span class=o>++</span> <span class=o>=</span> <span class=mh>0x0400</span> <span class=o>|</span> <span class=n>A9</span><span class=p>(</span><span class=n>LL</span><span class=p>(</span><span class=n>addr</span><span class=p>)));</span> <span class=p>}</span>
<span class=k>static</span> <span class=kt>int</span> <span class=nf>BRP</span><span class=p>(</span><span class=kt>int</span> <span class=n>addr</span><span class=p>)</span>              <span class=p>{</span> <span class=n>_L</span><span class=p>(</span><span class=o>*</span><span class=n>asmptr</span><span class=o>++</span> <span class=o>=</span> <span class=mh>0x0200</span> <span class=o>|</span> <span class=n>A9</span><span class=p>(</span><span class=n>LL</span><span class=p>(</span><span class=n>addr</span><span class=p>)));</span> <span class=p>}</span>
<span class=k>static</span> <span class=kt>int</span> <span class=nf>BRNZ</span><span class=p>(</span><span class=kt>int</span> <span class=n>addr</span><span class=p>)</span>             <span class=p>{</span> <span class=n>_L</span><span class=p>(</span><span class=o>*</span><span class=n>asmptr</span><span class=o>++</span> <span class=o>=</span> <span class=mh>0x0c00</span> <span class=o>|</span> <span class=n>A9</span><span class=p>(</span><span class=n>LL</span><span class=p>(</span><span class=n>addr</span><span class=p>)));</span> <span class=p>}</span>
<span class=k>static</span> <span class=kt>int</span> <span class=nf>BRNP</span><span class=p>(</span><span class=kt>int</span> <span class=n>addr</span><span class=p>)</span>             <span class=p>{</span> <span class=n>_L</span><span class=p>(</span><span class=o>*</span><span class=n>asmptr</span><span class=o>++</span> <span class=o>=</span> <span class=mh>0x0a00</span> <span class=o>|</span> <span class=n>A9</span><span class=p>(</span><span class=n>LL</span><span class=p>(</span><span class=n>addr</span><span class=p>)));</span> <span class=p>}</span>
<span class=k>static</span> <span class=kt>int</span> <span class=nf>BRZP</span><span class=p>(</span><span class=kt>int</span> <span class=n>addr</span><span class=p>)</span>             <span class=p>{</span> <span class=n>_L</span><span class=p>(</span><span class=o>*</span><span class=n>asmptr</span><span class=o>++</span> <span class=o>=</span> <span class=mh>0x0600</span> <span class=o>|</span> <span class=n>A9</span><span class=p>(</span><span class=n>LL</span><span class=p>(</span><span class=n>addr</span><span class=p>)));</span> <span class=p>}</span>

<span class=k>static</span> <span class=kt>int</span> <span class=nf>ADD</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>y</span><span class=p>,</span> <span class=kt>int</span> <span class=n>z</span><span class=p>)</span>   <span class=p>{</span> <span class=n>_L</span><span class=p>(</span><span class=o>*</span><span class=n>asmptr</span><span class=o>++</span> <span class=o>=</span> <span class=mh>0x1000</span> <span class=o>|</span> <span class=n>DR</span><span class=p>(</span><span class=n>x</span><span class=p>)</span> <span class=o>|</span> <span class=n>SR</span><span class=p>(</span><span class=n>y</span><span class=p>)</span> <span class=o>|</span> <span class=n>IR</span><span class=p>(</span><span class=n>z</span><span class=p>));</span> <span class=p>}</span>
<span class=k>static</span> <span class=kt>int</span> <span class=nf>AND</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>y</span><span class=p>,</span> <span class=kt>int</span> <span class=n>z</span><span class=p>)</span>   <span class=p>{</span> <span class=n>_L</span><span class=p>(</span><span class=o>*</span><span class=n>asmptr</span><span class=o>++</span> <span class=o>=</span> <span class=mh>0x5000</span> <span class=o>|</span> <span class=n>DR</span><span class=p>(</span><span class=n>x</span><span class=p>)</span> <span class=o>|</span> <span class=n>SR</span><span class=p>(</span><span class=n>y</span><span class=p>)</span> <span class=o>|</span> <span class=n>IR</span><span class=p>(</span><span class=n>z</span><span class=p>));</span> <span class=p>}</span>
<span class=k>static</span> <span class=kt>int</span> <span class=nf>NOT</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>y</span><span class=p>)</span>          <span class=p>{</span> <span class=n>_L</span><span class=p>(</span><span class=o>*</span><span class=n>asmptr</span><span class=o>++</span> <span class=o>=</span> <span class=mh>0x9000</span> <span class=o>|</span> <span class=n>DR</span><span class=p>(</span><span class=n>x</span><span class=p>)</span> <span class=o>|</span> <span class=n>SR</span><span class=p>(</span><span class=n>y</span><span class=p>)</span> <span class=o>|</span> <span class=mh>0x3f</span><span class=p>);</span>  <span class=p>}</span>

<span class=k>static</span> <span class=kt>int</span> <span class=nf>LEA</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>addr</span><span class=p>)</span>       <span class=p>{</span> <span class=n>_L</span><span class=p>(</span><span class=o>*</span><span class=n>asmptr</span><span class=o>++</span> <span class=o>=</span> <span class=mh>0xe000</span> <span class=o>|</span> <span class=n>DR</span><span class=p>(</span><span class=n>x</span><span class=p>)</span> <span class=o>|</span> <span class=n>A9</span><span class=p>(</span><span class=n>LL</span><span class=p>(</span><span class=n>addr</span><span class=p>)));</span> <span class=p>}</span>
<span class=k>static</span> <span class=kt>int</span> <span class=nf>LD</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>addr</span><span class=p>)</span>        <span class=p>{</span> <span class=n>_L</span><span class=p>(</span><span class=o>*</span><span class=n>asmptr</span><span class=o>++</span> <span class=o>=</span> <span class=mh>0x2000</span> <span class=o>|</span> <span class=n>DR</span><span class=p>(</span><span class=n>x</span><span class=p>)</span> <span class=o>|</span> <span class=n>A9</span><span class=p>(</span><span class=n>LL</span><span class=p>(</span><span class=n>addr</span><span class=p>)));</span> <span class=p>}</span>
<span class=k>static</span> <span class=kt>int</span> <span class=nf>LDI</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>addr</span><span class=p>)</span>       <span class=p>{</span> <span class=n>_L</span><span class=p>(</span><span class=o>*</span><span class=n>asmptr</span><span class=o>++</span> <span class=o>=</span> <span class=mh>0xa000</span> <span class=o>|</span> <span class=n>DR</span><span class=p>(</span><span class=n>x</span><span class=p>)</span> <span class=o>|</span> <span class=n>A9</span><span class=p>(</span><span class=n>LL</span><span class=p>(</span><span class=n>addr</span><span class=p>)));</span> <span class=p>}</span>
<span class=k>static</span> <span class=kt>int</span> <span class=nf>ST</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>addr</span><span class=p>)</span>        <span class=p>{</span> <span class=n>_L</span><span class=p>(</span><span class=o>*</span><span class=n>asmptr</span><span class=o>++</span> <span class=o>=</span> <span class=mh>0x3000</span> <span class=o>|</span> <span class=n>DR</span><span class=p>(</span><span class=n>x</span><span class=p>)</span> <span class=o>|</span> <span class=n>A9</span><span class=p>(</span><span class=n>LL</span><span class=p>(</span><span class=n>addr</span><span class=p>)));</span> <span class=p>}</span>
<span class=k>static</span> <span class=kt>int</span> <span class=nf>STI</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>addr</span><span class=p>)</span>       <span class=p>{</span> <span class=n>_L</span><span class=p>(</span><span class=o>*</span><span class=n>asmptr</span><span class=o>++</span> <span class=o>=</span> <span class=mh>0xb000</span> <span class=o>|</span> <span class=n>DR</span><span class=p>(</span><span class=n>x</span><span class=p>)</span> <span class=o>|</span> <span class=n>A9</span><span class=p>(</span><span class=n>LL</span><span class=p>(</span><span class=n>addr</span><span class=p>)));</span> <span class=p>}</span>
<span class=k>static</span> <span class=kt>int</span> <span class=nf>LDR</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>y</span><span class=p>,</span> <span class=kt>int</span> <span class=n>z</span><span class=p>)</span>   <span class=p>{</span> <span class=n>_L</span><span class=p>(</span><span class=o>*</span><span class=n>asmptr</span><span class=o>++</span> <span class=o>=</span> <span class=mh>0x6000</span> <span class=o>|</span> <span class=n>DR</span><span class=p>(</span><span class=n>x</span><span class=p>)</span> <span class=o>|</span> <span class=n>SR</span><span class=p>(</span><span class=n>y</span><span class=p>)</span> <span class=o>|</span> <span class=p>(</span><span class=n>z</span> <span class=o>&amp;</span> <span class=mh>0x3f</span><span class=p>));</span> <span class=p>}</span>
<span class=k>static</span> <span class=kt>int</span> <span class=nf>STR</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>y</span><span class=p>,</span> <span class=kt>int</span> <span class=n>z</span><span class=p>)</span>   <span class=p>{</span> <span class=n>_L</span><span class=p>(</span><span class=o>*</span><span class=n>asmptr</span><span class=o>++</span> <span class=o>=</span> <span class=mh>0x7000</span> <span class=o>|</span> <span class=n>DR</span><span class=p>(</span><span class=n>x</span><span class=p>)</span> <span class=o>|</span> <span class=n>SR</span><span class=p>(</span><span class=n>y</span><span class=p>)</span> <span class=o>|</span> <span class=p>(</span><span class=n>z</span> <span class=o>&amp;</span> <span class=mh>0x3f</span><span class=p>));</span> <span class=p>}</span>

<span class=k>static</span> <span class=kt>int</span> <span class=nf>JMP</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>)</span>                 <span class=p>{</span> <span class=n>_L</span><span class=p>(</span><span class=o>*</span><span class=n>asmptr</span><span class=o>++</span> <span class=o>=</span> <span class=mh>0xc000</span> <span class=o>|</span> <span class=n>SR</span><span class=p>(</span><span class=n>x</span><span class=p>));</span> <span class=p>}</span>
<span class=k>static</span> <span class=kt>int</span> <span class=nf>JSR</span><span class=p>(</span><span class=kt>int</span> <span class=n>addr</span><span class=p>)</span>              <span class=p>{</span> <span class=n>_L</span><span class=p>(</span><span class=o>*</span><span class=n>asmptr</span><span class=o>++</span> <span class=o>=</span> <span class=mh>0x4800</span> <span class=o>|</span> <span class=n>A9</span><span class=p>(</span><span class=n>LL</span><span class=p>(</span><span class=n>addr</span><span class=p>)));</span> <span class=p>}</span>
<span class=k>static</span> <span class=kt>int</span> <span class=nf>RET</span><span class=p>()</span>                      <span class=p>{</span> <span class=n>_L</span><span class=p>(</span><span class=o>*</span><span class=n>asmptr</span><span class=o>++</span> <span class=o>=</span> <span class=mh>0xc000</span> <span class=o>|</span> <span class=n>SR</span><span class=p>(</span><span class=n>R7</span><span class=p>));</span> <span class=p>}</span>

<span class=k>static</span> <span class=kt>int</span> <span class=nf>TRAP</span><span class=p>(</span><span class=kt>int</span> <span class=n>op</span><span class=p>)</span>               <span class=p>{</span> <span class=n>_L</span><span class=p>(</span><span class=o>*</span><span class=n>asmptr</span><span class=o>++</span> <span class=o>=</span> <span class=mh>0xf000</span> <span class=o>|</span> <span class=p>(</span><span class=n>op</span> <span class=o>&amp;</span> <span class=mh>0xff</span><span class=p>));</span> <span class=p>}</span>
<span class=k>static</span> <span class=kt>int</span> <span class=nf>GETC</span><span class=p>()</span>                     <span class=p>{</span> <span class=n>_L</span><span class=p>(</span><span class=n>TRAP</span><span class=p>(</span><span class=mh>0x20</span><span class=p>));</span> <span class=p>}</span>
<span class=k>static</span> <span class=kt>int</span> <span class=nf>PUTC</span><span class=p>()</span>                     <span class=p>{</span> <span class=n>_L</span><span class=p>(</span><span class=n>TRAP</span><span class=p>(</span><span class=mh>0x21</span><span class=p>));</span> <span class=p>}</span>
<span class=k>static</span> <span class=kt>int</span> <span class=nf>HALT</span><span class=p>()</span>                     <span class=p>{</span> <span class=n>_L</span><span class=p>(</span><span class=n>TRAP</span><span class=p>(</span><span class=mh>0x25</span><span class=p>));</span> <span class=p>}</span>

<span class=cp>#define LC3ASM() for (asmrun=2; asmrun &amp;&amp; (asmptr = asmbuf + 0x3000); asmrun--)
</span></code></pre></div><p><code>LL</code> is used for label addressing, since LC-3 uses relative jumps - instructions should contain offsets and not immediate addresses. <code>LC3ASM</code> is a helper macro to run assembly twice. The reason for a two-pass assembler is to handle labels that go <em>after</em> they are used, i.e.:<div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>int label;
LC3ASM {
        BR(label);
        ...
label = AND(R0, R0, 0);
        ...
}
</code></pre></div><p>On the first run <code>label</code> is an invalid address, which only becomes known when the first run is complete. On the second run <code>asmbuf</code> is regenerated with the correct address.<p>We can now write some assembly code and run it in the emulator. We can instrument our debugger to print register values, certain addresses, everything that we need as we will be building a more high-level language for our hand-crafted CPU.<p>A few notes on LC-3 assembly. There are no <code>mov</code> instructions. We would have to use arithmetics instead. There is also no subtraction, it should be done manually with negation and addition:<div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=c1>// To mov 5 into R0
</span><span class=c1></span><span class=n>AND</span><span class=p>(</span><span class=n>R0</span><span class=p>,</span> <span class=n>R0</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span> <span class=c1>// R0 := 0
</span><span class=c1></span><span class=n>ADD</span><span class=p>(</span><span class=n>R0</span><span class=p>,</span> <span class=n>R0</span><span class=p>,</span> <span class=mi>5</span><span class=p>);</span> <span class=c1>// R0 := R0 + 5
</span><span class=c1></span>
<span class=c1>// To subtract R2 from R3:
</span><span class=c1></span><span class=n>NOT</span><span class=p>(</span><span class=n>R2</span><span class=p>,</span> <span class=n>R2</span><span class=p>);</span>     <span class=c1>// R2 := ~R2;
</span><span class=c1></span><span class=n>ADD</span><span class=p>(</span><span class=n>R2</span><span class=p>,</span> <span class=n>R2</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>  <span class=c1>// R2 := ~R2 + 1 (AKA -R2);
</span><span class=c1></span><span class=n>ADD</span><span class=p>(</span><span class=n>R3</span><span class=p>,</span> <span class=n>R3</span><span class=p>,</span> <span class=n>R2</span><span class=p>);</span> <span class=c1>// R3 := R3 + (~R2 + 1) = R3 - R2
</span></code></pre></div><p>These constructs will happen often in our further assembly code. Perhaps I should have made macro-instructions for them.<h2 id=line-input>Line input</h2><p>The language we are going to implement using our LC-3 assembler is a Forth dialect, inspired by SectorForth. Before going deep into the language details we should figure out how to get user input. Forth uses space-separated words as the only language syntax, so naturally all input is line-oriented. First a line is stored into the so-called “terminal input buffer” (TIB), then it’s split into words and consumed word by word.<p>Our first task would be to read a line from the console into TIB. We would have to define the start address of the TIB. Then we would need a loop calling <code>TRAP(0x20)</code> to read a byte from console into R0 and store it inside TIB, advancing the pointer. The loop should continue until a newline is found. Ideally, we should check for buffer overflow, but it’s end of the world as we know it, so we can afford making some bugs.<div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=k>const</span> <span class=kt>int</span> <span class=n>TIB</span>  <span class=o>=</span> <span class=mh>0x4000</span><span class=p>;</span> <span class=cm>/* start of the terminal input buffer */</span>
<span class=k>const</span> <span class=kt>int</span> <span class=n>TOIN</span> <span class=o>=</span> <span class=mh>0x4100</span><span class=p>;</span> <span class=cm>/* next char in TIB (&gt;IN) */</span>

<span class=cm>/* readln: read a line until CR and fill in the TIB */</span>
<span class=n>readln</span> <span class=o>=</span> <span class=n>LD</span><span class=p>(</span><span class=n>R1</span><span class=p>,</span> <span class=n>tib</span><span class=p>);</span>        <span class=cm>/* load TIB address */</span>
         <span class=n>LD</span><span class=p>(</span><span class=n>R0</span><span class=p>,</span> <span class=n>toin</span><span class=p>);</span>       <span class=cm>/* load &gt;IN address */</span>
         <span class=n>STR</span><span class=p>(</span><span class=n>R1</span><span class=p>,</span> <span class=n>R0</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>     <span class=cm>/* make &gt;IN point at the start of TIB */</span>
<span class=n>readlp</span> <span class=o>=</span> <span class=n>TRAP</span><span class=p>(</span><span class=mh>0x20</span><span class=p>);</span>         <span class=cm>/* r0 = getchar() */</span>
         <span class=n>STR</span><span class=p>(</span><span class=n>R0</span><span class=p>,</span> <span class=n>R1</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>     <span class=cm>/* mem[r1] = r0 */</span>
         <span class=n>ADD</span><span class=p>(</span><span class=n>R1</span><span class=p>,</span> <span class=n>R1</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>     <span class=cm>/* r1 = r1 + 1 */</span>
         <span class=n>ADD</span><span class=p>(</span><span class=n>R0</span><span class=p>,</span> <span class=n>R0</span><span class=p>,</span> <span class=o>-</span><span class=mi>10</span><span class=p>);</span>   <span class=cm>/* is r0 == '\n' ? */</span>
         <span class=n>BRNP</span><span class=p>(</span><span class=n>readlp</span><span class=p>);</span>       <span class=cm>/* no: read another character */</span>
         <span class=n>ADD</span><span class=p>(</span><span class=n>R1</span><span class=p>,</span> <span class=n>R1</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>);</span>    <span class=cm>/* r1 = r1 - 1 to erase newline */</span>
         <span class=n>STR</span><span class=p>(</span><span class=n>R0</span><span class=p>,</span> <span class=n>R1</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>     <span class=cm>/* write 0 instead */</span>
         <span class=n>TRAP</span><span class=p>(</span><span class=mh>0x25</span><span class=p>);</span>         <span class=cm>/* halt */</span>
<span class=n>toin</span>   <span class=o>=</span> <span class=n>DW</span><span class=p>(</span><span class=n>TOIN</span><span class=p>);</span>
<span class=n>tib</span>    <span class=o>=</span> <span class=n>DW</span><span class=p>(</span><span class=n>TIB</span><span class=p>);</span>
</code></pre></div><p>Since the addresses for <code>TIB</code> and <code>&gt;IN</code> are rather large integers - we can’t load them directly, so we use intermediate cells containing the addresses and load them using <code>LD</code>. The rest is hopefully clear from the comments. <code>&gt;IN</code> is not used in this read loop, but it’s reset at the beginning so that the parser would continue fetching words from the beginning of the buffer after the line is read.<p>You can try running this code in our simulator. It would read a line and terminate. Printing out the contents of <code>asmbuf[0x4000...]</code> would show the entered line with a zero terminator at the end.<p>This code chunk uses R0 and R1 but the results are not passed via registers, rather via variables. For all the following code we would consider R0..R3 as “dirty” working registers, their initial values might be random, but functions can use them any time up to their needs. Registers R4..R7 would be special, they would have their own meaning in Forth, but we’ll cover it later. So let’s be lean when choosing which register to use.<h2 id=parser>Parser</h2><p>Now once we have a line read into TIB, we can start parsing it word by word. We would need a few loops here. First we need to skip leading whitespace. This would be the start of the word. Then we need to iterate over all non-whitespace bytes until the null terminator or a whitespace is found. That would be the end of the word.<p>Additionally, we would have to call the previous <code>readln</code> routine if the buffer is empty to read more data. Slightly adjusting <code>readln</code> we can build a <code>token</code> subroutine that always returns R2 pointing at the beginning of the next word token and R3 containing the length of that word:<div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=cm>/* token: parse a word from TIB, return its address (R2) and length (R3) */</span>
<span class=n>token</span> <span class=o>=</span>  <span class=n>LDI</span><span class=p>(</span><span class=n>R3</span><span class=p>,</span> <span class=n>toin</span><span class=p>);</span>      <span class=cm>/* r2 := &gt;IN */</span>
         <span class=n>LD</span><span class=p>(</span><span class=n>R1</span><span class=p>,</span> <span class=n>space</span><span class=p>);</span>      <span class=cm>/* r1 := ' ' (0x20) (ADD can't use imm 0x20, too big) */</span>
<span class=n>skipws</span> <span class=o>=</span> <span class=n>LDR</span><span class=p>(</span><span class=n>R0</span><span class=p>,</span> <span class=n>R3</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>     <span class=cm>/* r0 := mem[&gt;IN] */</span>
         <span class=n>BRZ</span><span class=p>(</span><span class=n>readln</span><span class=p>);</span>        <span class=cm>/* (r0 == '\0') ? read another TIB */</span>
         <span class=n>AND</span><span class=p>(</span><span class=n>R2</span><span class=p>,</span> <span class=n>R3</span><span class=p>,</span> <span class=n>R3</span><span class=p>);</span>    <span class=cm>/* r2 := r3 (r2 is start of the token) */</span>
         <span class=n>ADD</span><span class=p>(</span><span class=n>R3</span><span class=p>,</span> <span class=n>R3</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>     <span class=cm>/* r3 := r3 + 1, next char */</span>
         <span class=n>ADD</span><span class=p>(</span><span class=n>R0</span><span class=p>,</span> <span class=n>R0</span><span class=p>,</span> <span class=n>R1</span><span class=p>);</span>    <span class=cm>/* (r0 == ' ')  ? skip whitespace */</span>
         <span class=n>BRZ</span><span class=p>(</span><span class=n>skipws</span><span class=p>);</span>
         <span class=n>ADD</span><span class=p>(</span><span class=n>R3</span><span class=p>,</span> <span class=n>R3</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>);</span>    <span class=cm>/* r3 := r3 - 1, roll back one char for the next loop */</span>
<span class=n>findws</span> <span class=o>=</span> <span class=n>ADD</span><span class=p>(</span><span class=n>R3</span><span class=p>,</span> <span class=n>R3</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>     <span class=cm>/* r3 := r3 + 1, go to next char */</span>
         <span class=n>LDR</span><span class=p>(</span><span class=n>R0</span><span class=p>,</span> <span class=n>R3</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>     <span class=cm>/* r0 := mem[r3] */</span>
         <span class=n>BRZ</span><span class=p>(</span><span class=n>tokend</span><span class=p>);</span>        <span class=cm>/* (r0 == '\0') ? done */</span>
         <span class=n>ADD</span><span class=p>(</span><span class=n>R0</span><span class=p>,</span> <span class=n>R0</span><span class=p>,</span> <span class=n>R1</span><span class=p>);</span>    <span class=cm>/* (r0 &lt;&gt; ' ')  ? not a space, continue */</span>
         <span class=n>BRNP</span><span class=p>(</span><span class=n>findws</span><span class=p>);</span>
<span class=n>tokend</span> <span class=o>=</span> <span class=n>STI</span><span class=p>(</span><span class=n>R3</span><span class=p>,</span> <span class=n>toin</span><span class=p>);</span>      <span class=cm>/* &gt;IN := r3 */</span>
         <span class=n>NOT</span><span class=p>(</span><span class=n>R1</span><span class=p>,</span> <span class=n>R2</span><span class=p>);</span>        <span class=cm>/* r1 := ~r2 */</span>
         <span class=n>ADD</span><span class=p>(</span><span class=n>R1</span><span class=p>,</span> <span class=n>R1</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>     <span class=cm>/* r1 := ~r2 + 1 */</span>
         <span class=n>ADD</span><span class=p>(</span><span class=n>R3</span><span class=p>,</span> <span class=n>R3</span><span class=p>,</span> <span class=n>R1</span><span class=p>);</span>    <span class=cm>/* r3 := r3 + (~r2 + 1) OR r3 := r3 - r2 (len = end-start) */</span>
         <span class=n>RET</span><span class=p>();</span>

 <span class=cm>/* readln: read a line until CR and fill in the TIB */</span>
<span class=n>readln</span> <span class=o>=</span> <span class=n>LD</span><span class=p>(</span><span class=n>R1</span><span class=p>,</span> <span class=n>tib</span><span class=p>);</span>        <span class=cm>/* load TIB address */</span>
         <span class=n>LD</span><span class=p>(</span><span class=n>R0</span><span class=p>,</span> <span class=n>toin</span><span class=p>);</span>       <span class=cm>/* load &gt;IN address */</span>
         <span class=n>STR</span><span class=p>(</span><span class=n>R1</span><span class=p>,</span> <span class=n>R0</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>     <span class=cm>/* make &gt;IN point at the start of TIB */</span>
<span class=n>readlp</span> <span class=o>=</span> <span class=n>TRAP</span><span class=p>(</span><span class=mh>0x20</span><span class=p>);</span>         <span class=cm>/* r0 = getchar() */</span>
         <span class=n>STR</span><span class=p>(</span><span class=n>R0</span><span class=p>,</span> <span class=n>R1</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>     <span class=cm>/* mem[r1] = r0 */</span>
         <span class=n>ADD</span><span class=p>(</span><span class=n>R1</span><span class=p>,</span> <span class=n>R1</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>     <span class=cm>/* r1 = r1 + 1 */</span>
         <span class=n>ADD</span><span class=p>(</span><span class=n>R0</span><span class=p>,</span> <span class=n>R0</span><span class=p>,</span> <span class=o>-</span><span class=mi>10</span><span class=p>);</span>   <span class=cm>/* is r0 == '\n' ? */</span>
         <span class=n>BRNP</span><span class=p>(</span><span class=n>readlp</span><span class=p>);</span>       <span class=cm>/* no: read another character */</span>
         <span class=n>ADD</span><span class=p>(</span><span class=n>R1</span><span class=p>,</span> <span class=n>R1</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>);</span>    <span class=cm>/* r1 = r1 - 1 to erase newline */</span>
         <span class=n>STR</span><span class=p>(</span><span class=n>R0</span><span class=p>,</span> <span class=n>R1</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>     <span class=cm>/* write 0 instead */</span>
         <span class=n>BR</span><span class=p>(</span><span class=n>token</span><span class=p>);</span>          <span class=cm>/* try to parse first token */</span>
<span class=n>space</span>  <span class=o>=</span> <span class=n>DW</span><span class=p>(</span><span class=o>-</span><span class=mi>32</span><span class=p>);</span>
<span class=n>toin</span>   <span class=o>=</span> <span class=n>DW</span><span class=p>(</span><span class=n>TOIN</span><span class=p>);</span>
<span class=n>tib</span>    <span class=o>=</span> <span class=n>DW</span><span class=p>(</span><span class=n>TIB</span><span class=p>);</span>
</code></pre></div><p>Unfortunately, we have to store the whitespace symbol (ASCII 32) in a separate memory cell because it’s too large to be an immediate value. Making it a negative integer saves us from subtraction instruction combo, so that we could use <code>ADD</code> instead. Now, if we call <code>JSR(token)</code> in a loop and print memory between R2 and R2+R3 after it - we would be getting word by word from the console. At this point we can start implementing the core of our post-apocalyptic Forth interpreter.<h2 id=dictionary>Dictionary</h2><p>Before we start implementing the main interpreter loop, let’s agree on how Forth memory layout would look like.<p>Typically, a Forth VM uses two stacks - one for temporary variables (data stack), another for subroutine return addresses (return stack). We have the luxury of using dedicated registers as top stack pointers, but the start addresses of the stack must be predefined. We can use some arbitrary ranges, like 0x5000 for data and 0x6000 for return stack. We can also assign R5 to be the data stack pointer and R6 to be the return stack pointer. Let’s also make R4 an “instruction” pointer that would need a bit later. These three registers are sacred and no assembly code should use them beyond their primary purpose.<div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>const int SPADDR = 0x5000; /* data stack address */
const int RPADDR = 0x6000; /* return stack address */

const int IP = R4; /* instruction pointer */
const int SP = R5; /* data stack pointer */
const int RP = R6; /* return stack pointer */
</code></pre></div><p>It’s now becoming clear how some of the Forth words could be implemented. For example <code>@</code> would be taking a value from SP and fetching one cell of data at the address. <code>!</code> would be fetching a value and address from SP and saving the value there. <code>+</code> would be fetching two values from SP and adding them and so on:<div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>// @ (addr -- x)
LDR(R0, SP, 0);
LDR(R0, R0, 0);
STR(R0, SP, 0);

// ! (x addr --)
LDR(R0, SP, 0);
LDR(R1, SP, -1);
STR(R1, R0, 0);
ADD(SP, SP, -2);

// + (x y -- x+y)
LDR(R0, SP, 0);
LDR(R1, SP, -1);
ADD(R1, R1, R0);
ADD(SP, SP, -1);
STR(R1, SP, 0);
</code></pre></div><p>All these Forth words must be stored in a dictionary, so that Forth interpreter would be able to find them by their name and execute. It’s time to define the dictionary structure.<p>To keep things simple, a dictionary would be a linked list where each word contains a link to the previous word. Scanning a dictionary starts from the end of the list and goes to the head of it.<p>Besides, each word would be containing the word name and its name length, and some optional flags that might help with the execution of certain words (i.e. execute them immediately or compile them into the dictionary). Don’t bother too much with the flags, let’s just reserve a single byte for them and deal with it later. After the word header the body of the word comes, ending with a special <code>BR(next)</code> instruction that stops the execution of the current word and goes to the next one:<div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=n>next</span> <span class=o>=</span> <span class=n>LDR</span><span class=p>(</span><span class=n>R0</span><span class=p>,</span> <span class=n>IP</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
       <span class=n>ADD</span><span class=p>(</span><span class=n>IP</span><span class=p>,</span> <span class=n>IP</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
       <span class=n>JMP</span><span class=p>(</span><span class=n>R0</span><span class=p>);</span>
</code></pre></div><p>Since words are a linked list, we should store the address of the last word somewhere to simplify the creation of the new words. Typically a variable called “LATEST” is used for that.<p>We would need two more variables for a functional interpreter. One is to keep the interpreter state – interpreting words as they are typed, or compiling words into the new word definition. A variable <code>STATE</code> is used for that:<div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>       2 2 +      \ &lt;- these words are evaluated as they are entered,
                  \    immediately.
: four 2 2 + ;    \ &lt;- these words are appeneded to the "four" word 
                  \    entry in the dictionary as they are entered.
</code></pre></div><p>The last variable would be <code>HERE</code>, storing a pointer to the latest appended (compiled) instruction of the latest word.<p>For convenience we can define a macro to define primitive words and variables. These words would be defined by the interpreter itself, in machine code, and would be stored at the beginning of the dictionary:<div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>/* WORD creates a new word record without a body */
static void WORD(const char *name, int flags) {
  int i;
  link = DW(link); /* link to the previous word */
  DW(strlen(name) + flags); /* length + flags */
  for (i = 0; i &lt; strlen(name); i++) {
    DW(name[i]); /* word name */
  }
}

/* VAR creates a new word that pushes the pointer to the data stack */
static void VAR(const char *name, int ptr, int next) {
  WORD(name, 0);
  LD(R0, ptr);
  ADD(SP, SP, 1);
  STR(R0, SP, 0);
  BR(next);
}

...

/* @ ( addr -- x )       Fetch memory at addr */
WORD("@", 0);
LDR(R0, SP, 0);
LDR(R0, R0, 0);
STR(R0, SP, 0);
BR(next);

/* ! ( x addr -- )       Store x at addr */
WORD("!", 0);
LDR(R0, SP, 0);
LDR(R1, SP, -1);
STR(R1, R0, 0);
ADD(SP, SP, -2);
BR(next);

...

latest = DW(LATEST);
state  = DW(STATE);
here   = DW(HERE);

VAR("latest", latest, next);
VAR("state", state, next);
VAR("here", here, next);
</code></pre></div><p>Now if we scan the dictionary for word “state” and execute its body - it would put the value of the STATE variable onto stack. Similarly, if we scan the dictionary for the word “@” and execute it - it would allow us to fetch the value at given address. Implementing this lookup mechanism would give us a working interpreter and would successfully end our quest.<h2 id=interpreter>Interpreter</h2><p>The interpreter starts with requesting a new token. Due to the scarcity of registers we should probably store new token pointer and its length somewhere. Data stack is a good choice, we wouldn’t need it during the interpreter lookup procedure anyway.<p>Then we should take the latest word, starting with the LATEST variable, and compare its length and its name to the token. If either length or any character in the name differs - we should continue our search. If the next word pointer becomes zero - we reached the end of the dictionary and the word is not found. This is a fatal error for our interpreter, at which we reset it brutally and start again. Apocalypse is not a time for typos in code.<p>Once the word is found – we should check the interpreter state. If it’s compiling – we should append the word start address to the current word definition. If it’s interpreting immediately - we should jump to the word body address and let it go from there.<p>It’s a rather long piece of code, but believe it or not, it contains the complete Forth interpreter for our VM.<div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=cm>/* read/eval main interpreter loop */</span>
<span class=n>intrp</span> <span class=o>=</span>  <span class=n>JSR</span><span class=p>(</span><span class=n>token</span><span class=p>);</span>         <span class=cm>/* r1, r2 := (start, length) of the token in TIB */</span>
         <span class=n>STR</span><span class=p>(</span><span class=n>R2</span><span class=p>,</span> <span class=n>SP</span><span class=p>,</span> <span class=mi>2</span><span class=p>);</span>
         <span class=n>STR</span><span class=p>(</span><span class=n>R3</span><span class=p>,</span> <span class=n>SP</span><span class=p>,</span> <span class=mi>3</span><span class=p>);</span>
         <span class=n>LDI</span><span class=p>(</span><span class=n>R0</span><span class=p>,</span> <span class=n>latest</span><span class=p>);</span>    <span class=cm>/* r0 := [LATEST] */</span>
<span class=n>ismtch</span> <span class=o>=</span> <span class=n>BRZ</span><span class=p>(</span><span class=n>error</span><span class=p>);</span>         <span class=cm>/* if r0 == 0: goto error (word not found) */</span>
         <span class=n>STR</span><span class=p>(</span><span class=n>R0</span><span class=p>,</span> <span class=n>SP</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>     <span class=cm>/* push word code onto SP stack */</span>
         <span class=n>LDR</span><span class=p>(</span><span class=n>R1</span><span class=p>,</span> <span class=n>SP</span><span class=p>,</span> <span class=mi>2</span><span class=p>);</span>
         <span class=n>LDR</span><span class=p>(</span><span class=n>R2</span><span class=p>,</span> <span class=n>SP</span><span class=p>,</span> <span class=mi>3</span><span class=p>);</span>
         <span class=n>LDR</span><span class=p>(</span><span class=n>R3</span><span class=p>,</span> <span class=n>R0</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>     <span class=cm>/* r3 := [link+1] (word length) */</span>
         <span class=n>AND</span><span class=p>(</span><span class=n>R3</span><span class=p>,</span> <span class=n>R3</span><span class=p>,</span> <span class=mh>0xf</span><span class=p>);</span>   <span class=cm>/* r3 := word length */</span>
         <span class=n>NOT</span><span class=p>(</span><span class=n>R3</span><span class=p>,</span> <span class=n>R3</span><span class=p>);</span>
         <span class=n>ADD</span><span class=p>(</span><span class=n>R3</span><span class=p>,</span> <span class=n>R3</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
         <span class=n>ADD</span><span class=p>(</span><span class=n>R3</span><span class=p>,</span> <span class=n>R3</span><span class=p>,</span> <span class=n>R2</span><span class=p>);</span>    <span class=cm>/* r3 := r3 - r2 (compare length) */</span>
         <span class=n>BRNP</span><span class=p>(</span><span class=n>nomtch</span><span class=p>);</span>       <span class=cm>/* if length differs - try next word */</span>
<span class=n>nextc</span> <span class=o>=</span>  <span class=n>LDR</span><span class=p>(</span><span class=n>IP</span><span class=p>,</span> <span class=n>R0</span><span class=p>,</span> <span class=mi>2</span><span class=p>);</span>     <span class=cm>/* ip := [r0+2] (nth word letter from dict) */</span>
         <span class=n>LDR</span><span class=p>(</span><span class=n>R3</span><span class=p>,</span> <span class=n>R1</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>     <span class=cm>/* r2 := [r1]   (nth word letter from token) */</span>
         <span class=n>NOT</span><span class=p>(</span><span class=n>R3</span><span class=p>,</span> <span class=n>R3</span><span class=p>);</span>
         <span class=n>ADD</span><span class=p>(</span><span class=n>R3</span><span class=p>,</span> <span class=n>R3</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
         <span class=n>ADD</span><span class=p>(</span><span class=n>R3</span><span class=p>,</span> <span class=n>R3</span><span class=p>,</span> <span class=n>IP</span><span class=p>);</span>    <span class=cm>/* compare ip and r2 */</span>
         <span class=n>BRNP</span><span class=p>(</span><span class=n>nomtch</span><span class=p>);</span>       <span class=cm>/* if letters don't match - try next word */</span>
         <span class=n>ADD</span><span class=p>(</span><span class=n>R1</span><span class=p>,</span> <span class=n>R1</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>     <span class=cm>/* advance letter counter for token */</span>
         <span class=n>ADD</span><span class=p>(</span><span class=n>R0</span><span class=p>,</span> <span class=n>R0</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>     <span class=cm>/* advance letter counter for dict */</span>
         <span class=n>ADD</span><span class=p>(</span><span class=n>R2</span><span class=p>,</span> <span class=n>R2</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>);</span>    <span class=cm>/* decrease remaining length */</span>
         <span class=n>BRZ</span><span class=p>(</span><span class=n>found</span><span class=p>);</span>         <span class=cm>/* if remaining length == 0: found a word! */</span>
         <span class=n>BR</span><span class=p>(</span><span class=n>nextc</span><span class=p>);</span>
<span class=n>nomtch</span> <span class=o>=</span> <span class=n>LDR</span><span class=p>(</span><span class=n>R0</span><span class=p>,</span> <span class=n>SP</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>     <span class=cm>/* restore link */</span>
         <span class=n>LDR</span><span class=p>(</span><span class=n>R0</span><span class=p>,</span> <span class=n>R0</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>     <span class=cm>/* r0 := [r0] (next link) */</span>
         <span class=n>BR</span><span class=p>(</span><span class=n>ismtch</span><span class=p>);</span>
<span class=n>found</span> <span class=o>=</span>  <span class=n>ADD</span><span class=p>(</span><span class=n>R0</span><span class=p>,</span> <span class=n>R0</span><span class=p>,</span> <span class=mi>2</span><span class=p>);</span>
         <span class=n>LEA</span><span class=p>(</span><span class=n>IP</span><span class=p>,</span> <span class=n>loop</span><span class=p>);</span>
         <span class=n>LDI</span><span class=p>(</span><span class=n>R1</span><span class=p>,</span> <span class=n>state</span><span class=p>);</span>
         <span class=n>LDR</span><span class=p>(</span><span class=n>R2</span><span class=p>,</span> <span class=n>SP</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>     <span class=cm>/* restore word code from SP */</span>
         <span class=n>LDR</span><span class=p>(</span><span class=n>R2</span><span class=p>,</span> <span class=n>R2</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>     <span class=cm>/* get word length and flags */</span>
         <span class=n>AND</span><span class=p>(</span><span class=n>R2</span><span class=p>,</span> <span class=n>R2</span><span class=p>,</span> <span class=mh>0x10</span><span class=p>);</span>
         <span class=n>ADD</span><span class=p>(</span><span class=n>R2</span><span class=p>,</span> <span class=n>R2</span><span class=p>,</span> <span class=n>R1</span><span class=p>);</span>
         <span class=n>ADD</span><span class=p>(</span><span class=n>R2</span><span class=p>,</span> <span class=n>R2</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>);</span>
         <span class=n>BRZ</span><span class=p>(</span><span class=n>compil</span><span class=p>);</span>
         <span class=n>JMP</span><span class=p>(</span><span class=n>R0</span><span class=p>);</span>
<span class=n>loop</span> <span class=o>=</span>   <span class=n>DW</span><span class=p>(</span><span class=n>intrp</span><span class=p>);</span>
</code></pre></div><p>What’s missing here is the “compile” part, which does nothing more but storing R0 into <code>HERE</code> and advancing the <code>HERE</code> address:<div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=n>compil</span> <span class=o>=</span> <span class=n>LDI</span><span class=p>(</span><span class=n>R1</span><span class=p>,</span> <span class=n>here</span><span class=p>);</span>
         <span class=n>STR</span><span class=p>(</span><span class=n>R0</span><span class=p>,</span> <span class=n>R1</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>  <span class=cm>/* here := r0 */</span>
         <span class=n>ADD</span><span class=p>(</span><span class=n>R1</span><span class=p>,</span> <span class=n>R1</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
         <span class=n>STI</span><span class=p>(</span><span class=n>R1</span><span class=p>,</span> <span class=n>here</span><span class=p>);</span>   <span class=cm>/* here := here + 1 */</span>
         <span class=n>BR</span><span class=p>(</span><span class=n>next</span><span class=p>);</span>
</code></pre></div><p>Actually, if we launch our interpreter at this point, define some primitive words like “1”, “2” or “+” and ask it to evaluate “1 2 +” – it would be able to find and interpret all the words correctly, leaving <code>3</code> at the top of the data stack.<p>But we need to support user-defined words, too. User words usually start with <code>:</code> word and end with <code>;</code>. So all we need to do is to define primitives for <code>:</code> and <code>;</code>.<p>Let’s start with <code>;</code>. This is the only immediate word in our dictionary and the reason we had the flags byte. When this word is found and the interpreter is in the compilation state - it evaluates the word <code>;</code> immediately anyway, instead of compiling it.<p>What <code>;</code> does is switching the interpreter to the regular state (interpreting) and appends “exit” word to the end of the current word definition, which would pop the address from the return stack and jump to it:<div class=highlight><pre class=chroma><code class=language-c data-lang=c>         <span class=n>WORD</span><span class=p>(</span><span class=s>";"</span><span class=p>,</span> <span class=n>F_IMMEDIATE</span><span class=p>);</span>
         <span class=n>AND</span><span class=p>(</span><span class=n>R1</span><span class=p>,</span> <span class=n>R1</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
         <span class=n>STI</span><span class=p>(</span><span class=n>R1</span><span class=p>,</span> <span class=n>state</span><span class=p>);</span>  <span class=cm>/* state := 0 */</span>
         <span class=n>LEA</span><span class=p>(</span><span class=n>R0</span><span class=p>,</span> <span class=n>exit</span><span class=p>);</span>   <span class=cm>/* compile "exit" */</span>
         <span class=n>BRZ</span><span class=p>(</span><span class=n>compil</span><span class=p>);</span>

         <span class=n>WORD</span><span class=p>(</span><span class=s>"exit"</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
<span class=n>exit</span> <span class=o>=</span>   <span class=n>LDR</span><span class=p>(</span><span class=n>IP</span><span class=p>,</span> <span class=n>RP</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
         <span class=n>ADD</span><span class=p>(</span><span class=n>RP</span><span class=p>,</span> <span class=n>RP</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>);</span>
         <span class=n>BR</span><span class=p>(</span><span class=n>next</span><span class=p>);</span>
</code></pre></div><p>If you recall, in the interpreter loop before jumping to the word execution we stored the interpreter loop address into IP so that at the end of the word we would fall back to the interpreter.<p>Now, all that’s left is <code>:</code> word, allowing us to extend the dictionary with custom, user-defined words, like <code>: four 2 2 + ;</code>. What <code>:</code> does can be seen as two operations. First, it reads the next token and creates a new record in the dictionary. Then it compiles down the special <code>docol</code> word and switches the VM to the “compiling” state. All further tokens (words) get compiled into the current word definition until <code>;</code> is found, terminating the word.<p>Why is this <code>docol</code> so special and why is it needed at all?<div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>Subroutine threading:
                           ┌─────────┐
                     ┌────►│DUP:.... │
 ┌─────────┐         │     │     RET │
 │   DUP   ├──►call DUP    ├─────────┤
 ├─────────┤   call PLUS ─►│PLUS: ...│
 │  PLUS   │   call PRINT  │     RET │
 ├─────────┤          │    ├─────────┤
 │  PRINT  │          └───►│PRINT: ..│
 └─────────┘               │     RET │
                           └─────────┘

Direct threading:

                 ┌──────────────────────────────┐
                 │                              │
                 │         ┌─────────┐  ┌───────┴───┐
                 │   ┌────►│DUP:.... │  │next:      │
 ┌─────────┐     ▼   │     │ JMP next├──►  JMP(IP++)│
 │   DUP   ├──► jmp DUP    ├─────────┤  └───▲───▲───┘
 ├─────────┤    jmp PLUS ─►│PLUS: ...│      │   │
 │  PLUS   │    jmp PRINT  │ JMP next├──────┘   │
 ├─────────┤          │    ├─────────┤          │
 │  PRINT  │          └───►│PRINT: ..│          │
 └─────────┘               │ JMP next├──────────┘
                           └─────────┘
</code></pre></div><p>There’s a slight difference in these two illustrations.<p>If we were using subroutine threading - our words would be represented as a sequence of “call” instructions. Each “call” would put the IP on return stack, and restore it when the related subroutine exited, going to the next “call”. But we use direct threading here, and it’s <code>next</code> that increases the IP. So if suddenly while executing one word we want to call another, non-primitive, word - we should store the return address manually. What <code>docol</code> does is just this: push IP and jump to the next sub-word in the current word definition.<div class=highlight><pre class=chroma><code class=language-c data-lang=c>         <span class=n>WORD</span><span class=p>(</span><span class=s>":"</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
         <span class=n>JSR</span><span class=p>(</span><span class=n>token</span><span class=p>);</span>      <span class=cm>/* read next token after colon */</span>
         <span class=n>LDI</span><span class=p>(</span><span class=n>R0</span><span class=p>,</span> <span class=n>latest</span><span class=p>);</span>
         <span class=n>LDI</span><span class=p>(</span><span class=n>R1</span><span class=p>,</span> <span class=n>here</span><span class=p>);</span>
         <span class=n>STR</span><span class=p>(</span><span class=n>R0</span><span class=p>,</span> <span class=n>R1</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>  <span class=cm>/* [HERE] := LATEST (write link) */</span>
         <span class=n>STI</span><span class=p>(</span><span class=n>R1</span><span class=p>,</span> <span class=n>latest</span><span class=p>);</span> <span class=cm>/* LATEST := HERE (update latest pointer) */</span>
         <span class=n>STR</span><span class=p>(</span><span class=n>R3</span><span class=p>,</span> <span class=n>R1</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>  <span class=cm>/* write word length at [HERE+1] */</span>
         <span class=n>ADD</span><span class=p>(</span><span class=n>R1</span><span class=p>,</span> <span class=n>R1</span><span class=p>,</span> <span class=mi>2</span><span class=p>);</span>  <span class=cm>/* advance here by 2 cells */</span>
<span class=n>copy</span> <span class=o>=</span>   <span class=n>LDR</span><span class=p>(</span><span class=n>R0</span><span class=p>,</span> <span class=n>R2</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>  <span class=cm>/* copy from R2..(R2+R3) to HERE */</span>
         <span class=n>STR</span><span class=p>(</span><span class=n>R0</span><span class=p>,</span> <span class=n>R1</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
         <span class=n>ADD</span><span class=p>(</span><span class=n>R2</span><span class=p>,</span> <span class=n>R2</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
         <span class=n>ADD</span><span class=p>(</span><span class=n>R1</span><span class=p>,</span> <span class=n>R1</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
         <span class=n>ADD</span><span class=p>(</span><span class=n>R3</span><span class=p>,</span> <span class=n>R3</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>);</span>
         <span class=n>BRP</span><span class=p>(</span><span class=n>copy</span><span class=p>);</span>
         <span class=n>LD</span><span class=p>(</span><span class=n>R0</span><span class=p>,</span> <span class=n>op1</span><span class=p>);</span>     <span class=cm>/* store absolute jump to "docol" (see opcodes below) */</span>
         <span class=n>STR</span><span class=p>(</span><span class=n>R0</span><span class=p>,</span> <span class=n>R1</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>  <span class=cm>/* ... */</span>
         <span class=n>LD</span><span class=p>(</span><span class=n>R0</span><span class=p>,</span> <span class=n>op2</span><span class=p>);</span>     <span class=cm>/* ... */</span>
         <span class=n>STR</span><span class=p>(</span><span class=n>R0</span><span class=p>,</span> <span class=n>R1</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>  <span class=cm>/* ... */</span>
         <span class=n>LD</span><span class=p>(</span><span class=n>R0</span><span class=p>,</span> <span class=n>op3</span><span class=p>);</span>     <span class=cm>/* ... */</span>
         <span class=n>STR</span><span class=p>(</span><span class=n>R0</span><span class=p>,</span> <span class=n>R1</span><span class=p>,</span> <span class=mi>2</span><span class=p>);</span>  <span class=cm>/* ... */</span>
         <span class=n>ADD</span><span class=p>(</span><span class=n>R1</span><span class=p>,</span> <span class=n>R1</span><span class=p>,</span> <span class=mi>3</span><span class=p>);</span>  <span class=cm>/* advance HERE over those 3 instructions */</span>
         <span class=n>STI</span><span class=p>(</span><span class=n>R1</span><span class=p>,</span> <span class=n>here</span><span class=p>);</span>   <span class=cm>/* update HERE := R1 */</span>
         <span class=n>AND</span><span class=p>(</span><span class=n>R2</span><span class=p>,</span> <span class=n>R2</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>  <span class=cm>/* r2 := 0 */</span>
         <span class=n>ADD</span><span class=p>(</span><span class=n>R2</span><span class=p>,</span> <span class=n>R2</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>  <span class=cm>/* r2 := r2 + 1 */</span>
         <span class=n>STI</span><span class=p>(</span><span class=n>R2</span><span class=p>,</span> <span class=n>state</span><span class=p>);</span>  <span class=cm>/* state := 1 ("compiling") */</span>
         <span class=n>BR</span><span class=p>(</span><span class=n>next</span><span class=p>);</span>

<span class=n>op1</span>    <span class=o>=</span> <span class=n>DW</span><span class=p>(</span><span class=mh>0x2201</span><span class=p>);</span>      <span class=cm>/* LD(R1, PC+1) */</span>
<span class=n>op2</span>    <span class=o>=</span> <span class=n>DW</span><span class=p>(</span><span class=mh>0xc040</span><span class=p>);</span>      <span class=cm>/* JMP(R1)      */</span>
<span class=n>op3</span>    <span class=o>=</span> <span class=n>DW</span><span class=p>(</span><span class=n>docol</span><span class=p>);</span>       <span class=cm>/* FILL [docol] */</span>

<span class=n>docol</span>  <span class=o>=</span> <span class=n>STR</span><span class=p>(</span><span class=n>IP</span><span class=p>,</span> <span class=n>RP</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>  <span class=cm>/* store current IP on return stack */</span>
         <span class=n>ADD</span><span class=p>(</span><span class=n>RP</span><span class=p>,</span> <span class=n>RP</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
         <span class=n>ADD</span><span class=p>(</span><span class=n>IP</span><span class=p>,</span> <span class=n>R0</span><span class=p>,</span> <span class=mi>3</span><span class=p>);</span>  <span class=cm>/* skip compiled LD+JMP+FILL and advance IP */</span>
         <span class=n>BR</span><span class=p>(</span><span class=n>next</span><span class=p>);</span>
</code></pre></div><p>There is a quirky part with <code>op1</code>, <code>op2</code> and <code>op3</code>. Once the new word header is created, LATEST and HERE are both updated - we must compile some machine code that would jump to <code>docol</code> label. Since LC-3 has no support for absolute jumps, it could be either a relative or an indirect jump. Calculating relative addresses would be a nightmare, but an indirect jump is rather straightforward: store label address at some place, use <code>LD</code> to load it and perform a <code>JMP</code>. These three instructions are compiled literally into every non-primitive word definition:<div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>                 ┌────────┐
                 │: twice │
      ┌─────┐    ├────────┤
 IP=10│5    │ ┌─►│ docol  │ IP=50
      ├─────┤ │  ├────────┤
 IP=11│twice├─┘  │  dup   │ IP=51
      ├─────┤    ├────────┤
 IP=12│.    │◄┐  │   +    │ IP=52
      └─────┘ │  ├────────┤
              └──┤   ;    │ IP=53
                 └────────┘
</code></pre></div><p>Here’s an example of executing <code>5 twice .</code> which starts at IP=10 address. When it’s time to call <code>twice</code> the IP is incremented from 11 to 12 and <code>next</code> jumps to the first cell in <code>twice</code> word definition. That would be <code>docol</code> at address 50. It pushes IP=12 to RP stack, sets IP to 50 and calls <code>next</code>. This continues to <code>dup</code>, then <code>next</code>, then <code>+</code>, then <code>next</code>, then <code>;</code>, which restores the IP from the RP stack, setting it to 12 and jumping to it. This is how the interpreter returns back to the following <code>.</code> word.<p>With some luck we should be able to define the following primitive words in assembly:<div class=highlight><pre class=chroma><code class=language-forth data-lang=forth><span class=nf>WORDS:</span>
<span class=k>@ </span>   <span class=c1>( addr   -- x    )</span> <span class=c1>\ Fetch memory at addr
</span><span class=c1></span><span class=k>! </span>   <span class=c1>( x addr --      )</span> <span class=c1>\ Store x at addr
</span><span class=c1></span><span class=no>sp@ </span> <span class=c1>(        -- addr )</span> <span class=c1>\ Get current data pointer
</span><span class=c1></span><span class=no>rp@ </span> <span class=c1>(        -- addr )</span> <span class=c1>\ Get current stack pointer
</span><span class=c1></span><span class=nf>=0</span>   <span class=c1>( x      -- f    )</span> <span class=c1>\ if *sp == 0 then -1 else 0
</span><span class=c1></span><span class=k>+ </span>   <span class=c1>( a b    -- a+b  )</span> <span class=c1>\ add two values on top of the data stack
</span><span class=c1></span><span class=nf>nand</span> <span class=c1>( a b    -- n    )</span> <span class=c1>\ a NAND b
</span><span class=c1></span><span class=k>key </span> <span class=c1>(        -- k    )</span> <span class=c1>\ Read a key from console
</span><span class=c1></span><span class=k>emit </span><span class=c1>( c      --      )</span> <span class=c1>\ Write a character to console
</span><span class=c1></span><span class=k>bye </span> <span class=c1>(        --      )</span> <span class=c1>\ Terminate the VM
</span><span class=c1></span>
<span class=nf>VARIABLES:</span>
<span class=k>tib </span>   <span class=c1>\ TIB address (last line of input)
</span><span class=c1></span><span class=k>&gt;in </span>   <span class=c1>\ read pointer to TIB
</span><span class=c1></span><span class=nf>latest</span> <span class=c1>\ latest word address
</span><span class=c1></span><span class=k>state </span> <span class=c1>\ interpreter state
</span><span class=c1></span><span class=k>here </span>  <span class=c1>\ last compiled word address
</span></code></pre></div><p>If you are curious - please check out the <a href=https://github.com/zserge/lc3-forth>repo</a> to see how they are implemented.<h2 id=extending-our-forth>Extending our Forth</h2><p>At this point, our interpreter can evaluate primitive words and allows defining custom, compound words. But how useful is that if we don’t even have numbers?!<p>Let’s define our first word, the most useful one:<div class=highlight><pre class=chroma><code class=language-forth data-lang=forth><span class=c1>\ Fetch value from the top of the data stack, effectively duplicating it
</span><span class=c1></span><span class=kn>:</span> <span class=nc>dup</span>  <span class=no>sp@ </span><span class=k>@ ;
</span></code></pre></div><p>Now we can define some numbers!<div class=highlight><pre class=chroma><code class=language-forth data-lang=forth><span class=kn>:</span> <span class=nc>-1</span>  <span class=k>dup dup </span><span class=nf>nand</span> <span class=k>dup dup </span><span class=nf>nand</span> <span class=nf>nand</span> <span class=k>;
</span><span class=k></span><span class=kn>:</span> <span class=nc>0</span> <span class=mi>-1</span> <span class=k>dup </span><span class=nf>nand</span> <span class=k>;
</span><span class=k></span><span class=kn>:</span> <span class=nc>1</span> <span class=mi>-1</span> <span class=k>dup + dup </span><span class=nf>nand</span> <span class=k>;
</span><span class=k></span><span class=kn>:</span> <span class=nc>2</span> <span class=mi>1</span> <span class=mi>1</span> <span class=k>+ ;
</span><span class=k></span><span class=kn>:</span> <span class=nc>3</span> <span class=mi>2</span> <span class=mi>1</span> <span class=k>+ ;
</span><span class=k></span><span class=kn>:</span> <span class=nc>4</span> <span class=mi>2</span> <span class=mi>2</span> <span class=k>+ ;
</span><span class=k></span><span class=kt>...</span>
<span class=kn>:</span> <span class=nc>16</span> <span class=mi>8</span> <span class=mi>8</span> <span class=k>+ ;
</span></code></pre></div><p>Here only <code>-1</code> is a tricky one. For any value n on stack that would calculate:<div class=highlight><pre class=chroma><code class=language-forth data-lang=forth><span class=kn>:</span> <span class=nc>-1</span>   <span class=c1>\ n
</span><span class=c1></span>  <span class=k>dup </span> <span class=c1>\ n n
</span><span class=c1></span>  <span class=k>dup </span> <span class=c1>\ n n n
</span><span class=c1></span>  <span class=nf>nand</span> <span class=c1>\ n !n       (n NAND n = NOT n)
</span><span class=c1></span>  <span class=k>dup </span> <span class=c1>\ n !n !n
</span><span class=c1></span>  <span class=k>dup </span> <span class=c1>\ n !n !n !n
</span><span class=c1></span>  <span class=nf>nand</span> <span class=c1>\ n !n n     (!n NAND !n = n)
</span><span class=c1></span>  <span class=nf>nand</span> <span class=c1>\ n !0       (n AND !n = 0, n NAND !n = !0 = -1)
</span><span class=c1></span>  <span class=k>;
</span></code></pre></div><p>This would work with an empty stack as well, since it does not modify the topmost stack value so if there’s some garbage stored in RAM at (sp-1) address - it would leave that and put <code>-1</code> over it. The rest of the number literals can be added ad infinitum using <code>nand</code> or <code>+</code>.<p>We can also introduce some arithmetic helpers:<div class=highlight><pre class=chroma><code class=language-forth data-lang=forth><span class=kn>:</span> <span class=nc>invert</span>  <span class=k>dup </span><span class=nf>nand</span> <span class=k>;
</span><span class=k></span><span class=kn>:</span> <span class=nc>and</span>  <span class=nf>nand</span> <span class=k>invert ;
</span><span class=k></span><span class=kn>:</span> <span class=nc>negate</span>  <span class=k>invert </span><span class=mi>1</span> <span class=k>+ ;
</span><span class=k></span><span class=kn>:</span> <span class=nc>-</span>  <span class=k>negate + ;
</span><span class=k></span><span class=kn>:</span> <span class=nc>=</span>  <span class=k>- 0= ;
</span><span class=k></span><span class=kn>:</span> <span class=nc>&lt;&gt;</span>  <span class=nf>=</span> <span class=k>invert ;
</span></code></pre></div><p>Time to add some typical Forth stack operations, since we now have arithmetics and a stack pointer variable:<div class=highlight><pre class=chroma><code class=language-forth data-lang=forth><span class=kn>:</span> <span class=nc>drop</span>  <span class=k>dup - + ;
</span><span class=k></span><span class=kn>:</span> <span class=nc>over</span>  <span class=no>sp@ </span><span class=mi>1</span> <span class=k>- @ ;
</span><span class=k></span><span class=kn>:</span> <span class=nc>swap</span>  <span class=k>over over </span><span class=no>sp@ </span><span class=mi>3</span> <span class=k>- ! </span><span class=no>sp@ </span><span class=mi>1</span> <span class=k>- ! ;
</span><span class=k></span><span class=kn>:</span> <span class=nc>nip</span>  <span class=k>swap drop ;
</span><span class=k></span><span class=kn>:</span> <span class=nc>2dup</span>  <span class=k>over over ;
</span><span class=k></span><span class=kn>:</span> <span class=nc>2drop</span>  <span class=k>drop drop ;
</span></code></pre></div><p>Easy so far? Let’s spice it up. So far our numbers were “calculated” at runtime, so every time we need a <code>16</code> - we perform lots of nands and dups only to get that number. Can we speed it up? Yes, we may introduce an “immediate” mode, where some Forth code is evaluated as it is entered and the result of it gets compiled into a word, say:<div class=highlight><pre class=chroma><code class=language-forth data-lang=forth><span class=c1>\ slow
</span><span class=c1></span><span class=kn>:</span> <span class=nc>four</span> <span class=mi>1</span> <span class=mi>1</span> <span class=mi>1</span> <span class=mi>1</span> <span class=k>+ + + ;
</span><span class=k></span><span class=c1>\ fast
</span><span class=c1></span><span class=kn>:</span> <span class=nc>four</span> <span class=nf>lit</span> <span class=nf>[</span> <span class=mi>1</span> <span class=mi>1</span> <span class=mi>1</span> <span class=mi>1</span> <span class=k>+ + + , </span><span class=nf>]</span> <span class=k>;
</span></code></pre></div><p>Here <code>[</code> and <code>]</code> outline the “immediate” mode, which evaluates the code as it gets entered (even if the word around is compiled). Comma is used to advance HERE pointer and <code>lit</code> uses the following cell as the literal to put on data stack, i.e. if the word definition contains <code>lit</code> followed by a cell with value 0x0004 - <code>lit</code> would put 0x0004 on stack and jump over it to the next instruction. Now, how do we implement these?<div class=highlight><pre class=chroma><code class=language-forth data-lang=forth><span class=c1>\ compile value to HERE, advance HERE
</span><span class=c1></span><span class=kn>:</span> <span class=nc>,</span>  <span class=k>here @ ! </span> <span class=k>here @ </span><span class=mi>1</span> <span class=k>+ here ! ;
</span><span class=k></span><span class=c1>\ mark last word as F_IMMEDIATE
</span><span class=c1></span><span class=kn>:</span> <span class=nc>immediate</span> <span class=nf>latest</span> <span class=k>@ </span><span class=mi>1</span> <span class=k>+ dup @ </span><span class=mi>16</span> <span class=k>or swap ! ;
</span><span class=k></span><span class=c1>\ enter "interpret" mode, immediately
</span><span class=c1></span><span class=kn>:</span> <span class=nc>[</span> <span class=mi>0</span> <span class=k>state ! ; immediate
</span><span class=k></span><span class=c1>\ leave "interpret" mode and keep compiling
</span><span class=c1></span><span class=kn>:</span> <span class=nc>]</span> <span class=mi>1</span> <span class=k>state ! ;
</span><span class=k></span><span class=c1>\ put next compiled value onto data stack
</span><span class=c1></span><span class=kn>:</span> <span class=nc>lit</span>  <span class=no>rp@ </span><span class=k>@ dup </span><span class=mi>1</span> <span class=k>+ </span><span class=no>rp@ </span><span class=k>! @ ;
</span></code></pre></div><p>With a few low-level pointer manipulations we can add core words to manage the return stack:<div class=highlight><pre class=chroma><code class=language-forth data-lang=forth><span class=kn>:</span> <span class=nc>&gt;rexit</span>  <span class=no>rp@ </span><span class=k>! ; </span>                
<span class=kn>:</span> <span class=nc>&gt;r</span>  <span class=no>rp@ </span><span class=k>@ swap </span><span class=no>rp@ </span><span class=k>! </span><span class=nf>&gt;rexit</span> <span class=k>; </span>               
<span class=kn>:</span> <span class=nc>r&gt;</span>  <span class=no>rp@ </span><span class=mi>1</span> <span class=k>- @ </span><span class=no>rp@ </span><span class=k>@ </span><span class=no>rp@ </span><span class=mi>1</span> <span class=k>- ! </span><span class=nf>lit</span> <span class=nf>[</span> <span class=k>here @ </span><span class=mi>3</span> <span class=k>+ , </span><span class=nf>]</span> <span class=no>rp@ </span><span class=k>! ; </span>                
</code></pre></div><p>This may look confusing at a first glance, because pushing data to the return stack does not seem to advance the rp@ pointer. But look closer how <code>&gt;rexit</code> works: it overwrites the return address with the value from the data stack <em>and</em> returns to that address. The semicolon in <code>&gt;r</code> is never executed!<p>Let’s try a simple example adding a few imaginative breakpoints to see how data and return stacks would look like. Breakpoints are notated in curly braces.<div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>: &gt;rexit  {G} rp@ ! {H} ;                 
: &gt;r  {C} rp@ @ {D} swap {E} rp@ ! {F} &gt;rexit ;                
3 {A} &gt;r {B}

    DATA | RET
A:  3    |      | About to enter &gt;r
C:  3    | A    | Inside &gt;r, A is return address
D:  3 A  | A    | Fetched rp@ to data stack
E:  A 3  | A    | Swapped values on data stack
F:  A    | 3    | Stored top data value at return stack pointer
G:  A    | 3 F  | Entered &gt;rexit, F is return address
H:       | 3 A  | Replaced return address with a value from data stack
B:       | 3    | And naturally returned to A+1, done!
</code></pre></div><p>Now we can implement plenty of other words, such as “rot”, branches, if/then/else, various loops. With some luck we can introduce variables and <code>create</code> word to define new words from within Forth. We can add a custom input parser, at least to support strings, but maybe a better input editor could also be created, to support arrow keys, line editing etc.<p>Finally, a code like this can be interactively entered into our Forth machine:<div class=highlight><pre class=chroma><code class=language-forth data-lang=forth><span class=kn>:</span> <span class=nc>four</span> <span class=mi>2</span> <span class=mi>2</span> <span class=k>+ ;
</span><span class=k></span><span class=nf>four</span> <span class=nf>four</span> <span class=mi>1</span> <span class=k>+ .s
</span><span class=k></span><span class=s>."</span> <span class=s>done</span><span class=nf>"</span> <span class=k>cr
</span><span class=k></span><span class=c1>\ Output:
</span><span class=c1>\ &lt;2&gt; 4 5
</span><span class=c1>\ done
</span></code></pre></div><p>Here we defined a custom word at runtime, put some values on data stack and called a debug routine (also written in Forth) to dump the contents of the data stack, printed some strings - that feels like a real programming language now!<h2 id=summary>Summary</h2><p>This is nothing but a little experiment to bootstrap a Forth system on a tiny limited CPU.<p>You may find the complete source code of the VM, the interpreter and the Forth “core library” at <a href=https://github.com/zserge/lc3-forth>github.com/zserge/lc3-forth</a><p>It takes 287 machine words, or 574 bytes. This could theoretically be designed on paper and entered by hand on some hexpad to program the first computer.<p>But sure, programming after the apocalypse is no fun, and this sort of bare metal engineering isn’t easy at all. Perhaps, this article could serve as an additional motivation to avoid the end of the world for as long as we can.<p>I hope you’ve enjoyed this article. You can follow – and contribute to – on <a href=https://github.com/zserge>Github</a>, <a href=https://twitter.com/zsergo>Twitter</a> or subscribe via <a href=https://zserge.com/rss.xml>rss</a>.<p class=date style=text-align:right><em>Aug 04, 2022</em><p>See also:
<a href=https://zserge.com/posts/too-many-forths/>Learn a language by writing too many Forths</a> and <a href=https://zserge.com/posts/>more</a>.</p></div><footer><p>©2012–2022 ·
<a class=h-card rel=me href=https://zserge.com/>Serge Zaitsev</a> ·
<a href=mailto:hello@zserge.com rel=me>hello@zserge.com</a></p></footer><noscript class=sf-hidden><img src="https://nullitics.com/file.gif"></noscript><script>document.currentScript.remove();!function(){"use strict";(t=>{const n="singlefile-infobar",e="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABAAgMAAADXB5lNAAABhmlDQ1BJQ0MgcHJvZmlsZQAAKJF9kj1Iw0AYht+mSkUrDnYQcchQnSyIijqWKhbBQmkrtOpgcukfNGlIUlwcBdeCgz+LVQcXZ10dXAVB8AfEydFJ0UVK/C4ptIjx4LiH9+59+e67A4RGhalm1wSgapaRisfEbG5VDLyiDwEAvZiVmKkn0osZeI6ve/j4ehfhWd7n/hz9St5kgE8kjjLdsIg3iGc2LZ3zPnGIlSSF+Jx43KACiR+5Lrv8xrnosMAzQ0YmNU8cIhaLHSx3MCsZKvE0cVhRNcoXsi4rnLc4q5Uaa9XJbxjMaytprtMcQRxLSCAJETJqKKMCCxFaNVJMpGg/5uEfdvxJcsnkKoORYwFVqJAcP/gb/O6tWZiadJOCMaD7xbY/RoHALtCs2/b3sW03TwD/M3Cltf3VBjD3SXq9rYWPgIFt4OK6rcl7wOUOMPSkS4bkSH6aQqEAvJ/RM+WAwVv6EGtu31r7OH0AMtSr5Rvg4BAYK1L2use9ezr79u+ZVv9+AFlNcp0UUpiqAAAACXBIWXMAAC4jAAAuIwF4pT92AAAAB3RJTUUH5AsHAB8H+DhhoQAAABl0RVh0Q29tbWVudABDcmVhdGVkIHdpdGggR0lNUFeBDhcAAAAJUExURQAAAICHi4qKioTuJAkAAAABdFJOUwBA5thmAAAAAWJLR0QCZgt8ZAAAAJJJREFUOI3t070NRCEMA2CnYAOyDyPwpHj/Va7hJ3FzV7zy3ET5JIwoAF6Jk4wzAJAkzxAYG9YRTgB+24wBgKmfrGAKTcEfAY4KRlRoIeBTgKOCERVaCPgU4Khge2GqKOBTgKOCERVaAEC/4PNcnyoSWHpjqkhwKxbcig0Q6AorXYF/+A6eIYD1lVbwG/jdA6/kA2THRAURVubcAAAAAElFTkSuQmCC",o="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABAAgMAAADXB5lNAAABhmlDQ1BJQ0MgcHJvZmlsZQAAKJF9kj1Iw0AYht+mSkUrDnYQcchQnSyIijqWKhbBQmkrtOpgcukfNGlIUlwcBdeCgz+LVQcXZ10dXAVB8AfEydFJ0UVK/C4ptIjx4LiH9+59+e67A4RGhalm1wSgapaRisfEbG5VDLyiDwEAvZiVmKkn0osZeI6ve/j4ehfhWd7n/hz9St5kgE8kjjLdsIg3iGc2LZ3zPnGIlSSF+Jx43KACiR+5Lrv8xrnosMAzQ0YmNU8cIhaLHSx3MCsZKvE0cVhRNcoXsi4rnLc4q5Uaa9XJbxjMaytprtMcQRxLSCAJETJqKKMCCxFaNVJMpGg/5uEfdvxJcsnkKoORYwFVqJAcP/gb/O6tWZiadJOCMaD7xbY/RoHALtCs2/b3sW03TwD/M3Cltf3VBjD3SXq9rYWPgIFt4OK6rcl7wOUOMPSkS4bkSH6aQqEAvJ/RM+WAwVv6EGtu31r7OH0AMtSr5Rvg4BAYK1L2use9ezr79u+ZVv9+AFlNcp0UUpiqAAAACXBIWXMAAC4jAAAuIwF4pT92AAAAB3RJTUUH5AsHAB8VC4EQ6QAAABl0RVh0Q29tbWVudABDcmVhdGVkIHdpdGggR0lNUFeBDhcAAAAJUExURQAAAICHi4qKioTuJAkAAAABdFJOUwBA5thmAAAAAWJLR0QCZgt8ZAAAAJtJREFUOI3NkrsBgCAMRLFwBPdxBArcfxXFkO8rbKWAAJfHJ9faf9vuYX/749T5NmShm3bEwbe2SxeuM4+2oxDL1cDoKtVUjRy+tH78Cv2CS+wIiQNC1AEhk4AQeUTMWUJMfUJMSEJMSEY8kIx4IONroaYAimNxsXp1PA7PxwfVL8QnowwoVC0lig07wDDVUjAdbAnjwtow/z/bDW7eI4M2KruJAAAAAElFTkSuQmCC",i="SingleFile",A="single-file-ui-element",r="\n\t.infobar {\n\t\tbackground-color: #737373;\n\t\tcolor: white;\n\t\tdisplay: flex;\n\t\tposition: fixed;\n\t\ttop: 16px;\n\t\tright: 16px;\n\t\theight: auto;\n\t\twidth: auto;\n\t\tmin-height: 24px;\n\t\tmin-width: 24px;\n\t\tbackground-position: center;\n\t\tbackground-repeat: no-repeat;\n\t\tz-index: 2147483647;\n\t\tmargin: 0 0 0 16px;\n\t\tbackground-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABABAMAAABYR2ztAAABhmlDQ1BJQ0MgcHJvZmlsZQAAKJF9kj1Iw0AYht+mSkUrDnYQcchQnSyIijqWKhbBQmkrtOpgcukfNGlIUlwcBdeCgz+LVQcXZ10dXAVB8AfEydFJ0UVK/C4ptIjx4LiH9+59+e67A4RGhalm1wSgapaRisfEbG5VDLyiDwEAvZiVmKkn0osZeI6ve/j4ehfhWd7n/hz9St5kgE8kjjLdsIg3iGc2LZ3zPnGIlSSF+Jx43KACiR+5Lrv8xrnosMAzQ0YmNU8cIhaLHSx3MCsZKvE0cVhRNcoXsi4rnLc4q5Uaa9XJbxjMaytprtMcQRxLSCAJETJqKKMCCxFaNVJMpGg/5uEfdvxJcsnkKoORYwFVqJAcP/gb/O6tWZiadJOCMaD7xbY/RoHALtCs2/b3sW03TwD/M3Cltf3VBjD3SXq9rYWPgIFt4OK6rcl7wOUOMPSkS4bkSH6aQqEAvJ/RM+WAwVv6EGtu31r7OH0AMtSr5Rvg4BAYK1L2use9ezr79u+ZVv9+AFlNcp0UUpiqAAAACXBIWXMAAC4jAAAuIwF4pT92AAAAB3RJTUUH5AsHADIRLMaOHwAAABl0RVh0Q29tbWVudABDcmVhdGVkIHdpdGggR0lNUFeBDhcAAAAPUExURQAAAIqKioyNjY2OjvDw8L2y1DEAAAABdFJOUwBA5thmAAAAAWJLR0QB/wIt3gAAAGNJREFUSMdjYCAJsLi4OBCQx6/CBQwIGIDPCBcXAkYQUsACU+AwlBVQHg6Eg5pgZBGOboIJZugDFwRwoJECJCUOhJI1wZwzqmBUwagCuipgIqTABG9h7YIKaKGAURAFEF/6AQAO4HqSoDP8bgAAAABJRU5ErkJggg==);\n\t\tborder-radius: 16px;\n\t\tuser-select: none;\n\t\t-moz-user-select: none;\n\t\topacity: .7;\n\t\tcursor: pointer;\n\t\tpadding-left: 0;\n\t\tpadding-right: 0;\n\t\tpadding-top: 0;\n\t\tpadding-bottom: 0;\n\t\tborder: 2px solid #eee;\n\t\tbackground-size: 70% 70%;\n\t\ttransition: all 250ms;\n\t\tfont-size: 13px;\n\t}\n\t.infobar:hover {\n\t\topacity: 1;\n\t}\n\t.infobar-open {\n\t\topacity: 1;\n\t\tbackground-color: #f9f9f9;\n\t\tcursor: auto;\n\t\tcolor: #2d2d2d;\n\t\tpadding-top: 2px;\n\t\tpadding-bottom: 2px;\n\t\tborder: 2px solid #878787;\n\t\tbackground-image: none;\n\t\tborder-radius: 8px;\n\t\tuser-select: initial;\n\t\t-moz-user-select: initial;\n\t}\n\t.infobar-close-button {\n\t\tdisplay: none;\n\t\topacity: .7;\n\t\tpadding-top: 4px;\n\t\tpadding-left: 8px;\n\t\tpadding-right: 8px;\n\t\tcursor: pointer;\n\t\ttransition: opacity 250ms;\n\t\theight: 16px;\n\t}\n\t.infobar-close-button:hover {\n\t\topacity: 1;\n\t}\n\t.infobar-content {\n\t\tdisplay: none;\n\t\tfont-family: Arial;\n\t\tfont-size: 14px;\n\t\tline-height: 22px;\n\t\tword-break: break-word;\n\t\twhite-space: pre-wrap;\n\t\tposition: relative;\n\t\ttop: 1px;\n\t\ttext-align: left;\n\t}\n\t.infobar-link {\n\t\tdisplay: none;\n\t\tpadding-left: 8px;\n\t\tpadding-right: 8px;\n\t\tline-height: 11px;\n\t\tcursor: pointer;\n\t\tuser-select: none;\n\t\toutline: 0;\n\t}\n\t.infobar-link-icon {\n\t\tpadding-top: 4px;\n\t\tpadding-left: 2px;\n\t\tcursor: pointer;\n\t\topacity: .7;\n\t\ttransition: opacity 250ms;\n\t\theight: 16px;\n\t}\n\t.infobar-link-icon:hover {\n\t\topacity: 1;\n\t}\n\t.infobar-open .infobar-close-button, .infobar-open .infobar-content, .infobar-open .infobar-link {\n\t\tdisplay: inline-block;\n\t}";let a=!0;const c=t.browser;async function s(){const t=document.evaluate("//comment()",document,null,XPathResult.FIRST_ORDERED_NODE_TYPE,null);let s=t&&t.singleNodeValue;if(s&&((p=s).nodeType==Node.COMMENT_NODE&&p.textContent.includes(i))){const t=s.textContent.split("\n"),[,,i,p,...g]=t,h=i.match(/^ url: (.*) $/),u=h&&h[1];if(u&&p){let t;if(c&&c.runtime&&c.runtime.sendMessage)try{t=await c.runtime.sendMessage({method:"tabs.getOptions",url:u})}catch(n){t={displayInfobar:!0}}else t={displayInfobar:!0};t.displayInfobar&&await async function(t,i,c){let s=document.querySelector(n);if(!s){if(i=i.split("saved date: ")[1],c&&c.length>1){let t=c[0].split("info: ")[1].trim();for(let n=1;n<c.length-1;n++)t+="\n"+c[n].trim();c=t.trim()}else c=i;s=d(n,document.body),s.className=A;const p=await async function(t){if(t.attachShadow)return t.attachShadow({mode:"open"});{a=!1;const n=d("iframe",t);return n.style.setProperty("background-color","transparent","important"),n.style.setProperty("position","fixed","important"),n.style.setProperty("top",0,"important"),n.style.setProperty("right",0,"important"),n.style.setProperty("width","44px","important"),n.style.setProperty("height","48px","important"),n.style.setProperty("z-index",2147483647,"important"),new Promise((t=>{n.contentDocument.body.style.setProperty("margin",0),n.onload=()=>t(n.contentDocument.body)}))}}(s),g=document.createElement("style");g.textContent=r,p.appendChild(g);const h=document.createElement("div");h.classList.add("infobar"),p.appendChild(h);const u=document.createElement("img");u.classList.add("infobar-close-button"),h.appendChild(u),u.src=o,u.onclick=t=>{0===t.button&&s.remove()};const m=document.createElement("span");h.appendChild(m),m.classList.add("infobar-content"),m.textContent=c;const b=document.createElement("a");b.classList.add("infobar-link"),h.appendChild(b),b.target="_blank",b.rel="noopener noreferrer",b.title="Open source URL: "+t,b.href=t;const f=document.createElement("img");f.classList.add("infobar-link-icon"),b.appendChild(f),f.src=e,l(h),document.addEventListener("click",(t=>{if(0===t.button){let n=t.target;for(;n&&n!=s;)n=n.parentElement;n!=s&&l(h)}}))}}(u,p,g)}}var p}function l(t){if(t.classList.remove("infobar-open"),t.onclick=e=>{if(0===e.button)return function(t){a||document.querySelector(n).childNodes[0].contentWindow.getSelection().removeAllRanges();if(t.classList.add("infobar-open"),t.onclick=null,t.onmouseout=null,!a){const e=document.querySelector(n).childNodes[0];e.style.setProperty("width","100vw","important"),e.style.setProperty("height","100vh","important"),e.style.setProperty("width",t.getBoundingClientRect().width+33+"px","important"),e.style.setProperty("height",t.getBoundingClientRect().height+21+"px","important")}}(t),!1},!a){const t=document.querySelector(n).childNodes[0];t.style.setProperty("width","44px","important"),t.style.setProperty("height","48px","important")}}function d(t,n){const e=document.createElement(t);return n.appendChild(e),Array.from(getComputedStyle(e)).forEach((t=>e.style.setProperty(t,"initial","important"))),e}t.window==t.top&&("loading"==document.readyState?document.addEventListener("DOMContentLoaded",s,!1):s())})("object"==typeof globalThis?globalThis:window)}();
</script>